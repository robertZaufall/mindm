Directory structure:
└── mindm/
    ├── README.md
    ├── LICENSE
    ├── pyproject.toml
    ├── update_version.py
    ├── mindm/
    │   ├── __init__.py
    │   ├── mindmanager.py
    │   ├── mindmanager_mac.py
    │   └── mindmanager_win.py
    └── mindmap/
        ├── __init__.py
        ├── export.py
        ├── helpers.py
        ├── import.py
        ├── mindmap.py
        └── serialization.py

================================================
File: README.md
================================================
# mindm

Python library for interacting with locally installed MindManager™ on Windows and macOS platforms.

[![PyPI version](https://img.shields.io/pypi/v/mindm.svg)](https://pypi.org/project/mindm/)
[![Documentation](https://img.shields.io/badge/docs-latest-blue.svg)](https://robertzaufall.github.io/mindm/)

## Installation

Install using `pip`:
```bash
pip install mindm
```

## Getting Started

### Low-level example

Example for iterating over all topics in a mindmap and changing the topic text to uppercase:  
  
```python
import mindm.mindmanager

def iterate_topics(topic):
    text = m.get_text_from_topic(topic)
    m.set_text_to_topic(topic, text.upper())

    subtopics = m.get_subtopics_from_topic(topic)
    for subtopic in subtopics:
        iterate_topics(subtopic)

m = mindm.mindmanager.Mindmanager()
central_topic = m.get_central_topic()
iterate_topics(central_topic)
```

### High-level examples
  
Example for loading a mindmap from an open mindmap document and cloning it to a new document:  
  
```python
import mindmap.mindmap as mm

document = mm.MindmapDocument()
document.get_mindmap()
document.create_mindmap()
```
  
Example for serializing a mindmap to YAML format:  
  
```python
import yaml
import mindmap.mindmap as mm
import mindmap.serialization as mms

document = mm.MindmapDocument()
document.get_mindmap()

guid_mapping = {}
mms.build_mapping(document.mindmap, guid_mapping)

yaml_data = mms.serialize_object(document.mindmap, guid_mapping)
print(yaml.dump(yaml_data, sort_keys=False))
```
  
Example for serializing / deserializing a mindmap to / from Mermaid format including all attributes:  
  
```python
import json
import mindmap.mindmap as mm
import mindmap.serialization as mms

document = mm.MindmapDocument()
document.get_mindmap()

guid_mapping = {}
mms.build_mapping(document.mindmap, guid_mapping)

serialized = mms.serialize_mindmap(document.mindmap, guid_mapping, id_only=False)
print(serialized)

deserialized = mms.deserialize_mermaid_full(serialized, guid_mapping)
print(json.dumps(mms.serialize_object_simple(deserialized), indent=1))

document_new = mm.MindmapDocument()
document_new.mindmap = deserialized
document_new.create_mindmap()
```

## Platform Specific Functionality

### Windows

Supported:
- topics (central topic + subtopics)
- notes
- icons
- images
- tags
- links (external and topic links)
- relationships
- rtf

Not Supported:
- floating topics
- callouts
- colors, lines, boundaries

### macOS

Supported:
- topics (central topic + subtopics)
- notes
- relationships

Not Supported:
- icons
- images
- tags
- links
- rtf
- floating topics
- callouts
- colors, lines, boundaries

## Documentation
[Link to GitHub Pages](https://robertzaufall.github.io/mindm/)


================================================
File: LICENSE
================================================
MIT License

Copyright (c) [2025] [Robert Zaufall]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "mindm"
version = "0.0.3.10"
authors = [
  { name="Robert Zaufall" },
]
description = "Python library for interacting with local installed MindManager(tm) on Windows and MacOS platform."
readme = "README.md"
requires-python = ">=3.9"
classifiers = [
    "Programming Language :: Python :: 3",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: MacOS :: MacOS X",
]

dependencies = [
  "pywin32; platform_system == 'Windows'",
  "appscript; sys_platform == 'darwin'",
  "regex",
  "html2text",
  "markdown"
]

[project.license]
text = "MIT"

[project.urls]
Homepage = "https://github.com/robertZaufall/mindm"
Issues = "https://github.com/robertZaufall/mindm/issues"

[project.optional-dependencies]
dev = [
  "pytest>=7.0",
  "black",
  "flake8",
  "gitingest",
]
docs = [
  "furo",
  "sphinx",
  "sphinx-pyproject",
  "sphinx.ext.autodoc",
  "sphinx.ext.napoleon",
  "sphinx.ext.autosummary",
]

[tool.setuptools.packages.find]
include = ["mindm", "mindmap"]
namespaces = false  # to disable scanning PEP 420 namespaces


================================================
File: update_version.py
================================================
#!/usr/bin/env python3
import re

# Read pyproject.toml
with open("pyproject.toml", "r") as f:
    content = f.read()

# Find version and update build number
version_pattern = r'version = "([\d]+)\.([\d]+)\.([\d]+)\.([\d]+)"'
version_match = re.search(version_pattern, content)

if version_match:
    major, minor, patch, build = version_match.groups()
    new_build = str(int(build) + 1)
    new_version = f"{major}.{minor}.{patch}.{new_build}"
    new_content = re.sub(version_pattern, f'version = "{new_version}"', content)
    
    # Write updated content back
    with open("pyproject.toml", "w") as f:
        f.write(new_content)
    
    print(f"Updated version to {new_version}")
else:
    print("Version pattern not found in pyproject.toml")


================================================
File: mindm/__init__.py
================================================
"""
mindm - Python library for interacting with local installed MindManager.

This package provides functionality to interact with MindManager on both
Windows and MacOS platforms. It allows reading, creating, and manipulating
mindmaps programmatically.

Main components:
- mindmap_helper: High-level interface for mindmap operations
- mindmanager: Platform-independent base class
- mindmanager_win: Windows-specific implementations
- mindmanager_mac: MacOS-specific implementations
"""

# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"


================================================
File: mindm/mindmanager.py
================================================
"""
Platform-independent interface for MindManager operations.

This module provides a unified interface for working with MindManager
across different platforms (Windows and MacOS) by delegating to the
appropriate platform-specific implementation.
"""

import sys

class Mindmanager():
    def __init__(self, charttype='auto'):
        """
        Initialize a Mindmanager instance and delegate to the platform-specific implementation.

        Args:
            charttype (any): The type of chart to initialize with.
        """
        if sys.platform.startswith('win'):
            import mindm.mindmanager_win as mm
            self.platform = "win"
        elif sys.platform.startswith('darwin'):
            import mindm.mindmanager_mac as mm
            self.platform = "darwin"

        self.mindm = mm.Mindmanager(charttype)

    def get_mindmanager_object(self) -> any:
        """
        Retrieve the MindManager application object.

        Returns:
            any: The MindManager application object.
        """
        return self.mindm.get_mindmanager_object()
    
    def get_active_document_object(self) -> any:
        """
        Retrieve the active document object.

        Returns:
            any: The active document object.
        """
        return self.mindm.get_active_document_object()
    
    def get_version(self) -> str:
        """
        Retrieve the version of the MindManager application.

        Returns:
            str: The version of the application.
        """
        return self.mindm.get_version()

    def get_library_folder(self) -> str:
        """
        Retrieve the library folder path for the MindManager application.

        Returns:
            str: The library folder path.
        """
        return self.mindm.get_library_folder()

    def merge_windows(self) -> None:
        """
        Merge multiple windows into a single window.

        Returns:
            None
        """
        return self.mindm.merge_windows()

    def set_document_background_image(self, path: str) -> None:
        """
        Set the background image for the document.

        Args:
            path (str): The path to the background image.

        Returns:
            None
        """
        return self.mindm.set_document_background_image(path)

    def document_exists(self) -> bool:
        """
        Check if a document exists in the current context.

        Returns:
            bool: True if the document exists, False otherwise.
        """
        return self.mindm.document_exists()

    def get_central_topic(self) -> any:
        """
        Retrieve the central topic of the mind map.

        Returns:
            any: The central topic.
        """
        return self.mindm.get_central_topic()

    def get_topic_by_id(self, id: any) -> any:
        """
        Retrieve a topic by its identifier.

        Args:
            id (any): The identifier of the topic.

        Returns:
            any: The topic corresponding to the given id.
        """
        return self.mindm.get_topic_by_id(id)

    def get_selection(self) -> list:
        """
        Get the currently selected topics.

        Returns:
            list: A list of selected topics.
        """
        return self.mindm.get_selection()

    def get_level_from_topic(self, topic: any) -> any:
        """
        Get the level of the given topic within the mind map hierarchy.

        Args:
            topic (any): The topic to evaluate.

        Returns:
            any: The level of the topic.
        """
        return self.mindm.get_level_from_topic(topic)

    def get_text_from_topic(self, topic: any) -> str:
        """
        Retrieve the text content of a topic.

        Args:
            topic (any): The topic to extract text from.

        Returns:
            str: The text content of the topic.
        """
        return self.mindm.get_text_from_topic(topic)

    def get_title_from_topic(self, topic: any) -> str:
        """
        Retrieve the title of a topic.

        Args:
            topic (any): The topic to extract the title from.

        Returns:
            str: The title of the topic.
        """
        return self.mindm.get_title_from_topic(topic)

    def get_subtopics_from_topic(self, topic: any) -> list:
        """
        Retrieve all subtopics for the specified topic.

        Args:
            topic (any): The parent topic.

        Returns:
            list: A list of subtopics.
        """
        return self.mindm.get_subtopics_from_topic(topic)

    def get_links_from_topic(self, topic: any) -> list:
        """
        Retrieve all links associated with the specified topic.

        Args:
            topic (any): The topic to extract links from.

        Returns:
            list: A list of links.
        """
        return self.mindm.get_links_from_topic(topic)

    def get_image_from_topic(self, topic: any) -> any:
        """
        Retrieve the image associated with the topic.

        Args:
            topic (any): The topic to extract the image from.

        Returns:
            any: The image object or path.
        """
        return self.mindm.get_image_from_topic(topic)

    def get_icons_from_topic(self, topic: any) -> list:
        """
        Retrieve all icons associated with the topic.

        Args:
            topic (any): The topic to extract icons from.

        Returns:
            list: A list of icons.
        """
        return self.mindm.get_icons_from_topic(topic)

    def get_notes_from_topic(self, topic: any) -> any:
        """
        Retrieve the notes for the specified topic.

        Args:
            topic (any): The topic to extract notes from.

        Returns:
            any: The notes of the topic.
        """
        return self.mindm.get_notes_from_topic(topic)

    def get_tags_from_topic(self, topic: any) -> list:
        """
        Retrieve all tags attached to the topic.

        Args:
            topic (any): The topic to extract tags from.

        Returns:
            list: A list of tags.
        """
        return self.mindm.get_tags_from_topic(topic)

    def get_references_from_topic(self, topic: any) -> list:
        """
        Retrieve all references associated with the topic.

        Args:
            topic (any): The topic to extract references from.

        Returns:
            list: A list of references.
        """
        return self.mindm.get_references_from_topic(topic)

    def get_guid_from_topic(self, topic: any) -> str:
        """
        Retrieve the GUID (Globally Unique Identifier) of the topic.

        Args:
            topic (any): The topic to extract the GUID from.

        Returns:
            str: The GUID of the topic.
        """
        return self.mindm.get_guid_from_topic(topic)

    def add_subtopic_to_topic(self, topic: any, topic_text: str) -> any:
        """
        Add a subtopic with the provided text to an existing topic.

        Args:
            topic (any): The parent topic.
            topic_text (str): The text for the new subtopic.

        Returns:
            any: The newly created subtopic.
        """
        return self.mindm.add_subtopic_to_topic(topic, topic_text)

    def get_parent_from_topic(self, topic: any) -> any:
        """
        Retrieve the parent topic of the given topic.

        Args:
            topic (any): The topic to find the parent for.

        Returns:
            any: The parent topic.
        """
        return self.mindm.get_parent_from_topic(topic)

    def set_text_to_topic(self, topic: any, topic_text: str) -> None:
        """
        Set the text content for the specified topic.

        Args:
            topic (any): The topic to update.
            topic_text (str): The new text content.

        Returns:
            None
        """
        return self.mindm.set_text_to_topic(topic, topic_text)

    def set_title_to_topic(self, topic: any, topic_rtf: str) -> None:
        """
        Set the title (as RTF) for the specified topic.

        Args:
            topic (any): The topic to update.
            topic_rtf (str): The new title in RTF format.

        Returns:
            None
        """
        return self.mindm.set_title_to_topic(topic, topic_rtf)

    def add_tag_to_topic(self, topic: any, tag_text: str, topic_guid: str) -> None:
        """
        Add a tag to the specified topic.

        Args:
            topic (any): The topic to update.
            tag_text (str): The tag text to add.

        Returns:
            None
        """
        return self.mindm.add_tag_to_topic(topic, tag_text, topic_guid)

    def set_topic_from_mindmap_topic(self, topic: any, mindmap_topic: any, map_icons: any) -> any:
        """
        Update or create a topic based on the provided mindmap topic and icons.

        Args:
            topic (any): The current topic to update.
            mindmap_topic (any): The reference mindmap topic data.
            map_icons (any): Icons mapping for the topic.

        Returns:
            any: The updated topic.
        """
        return self.mindm.set_topic_from_mindmap_topic(topic, mindmap_topic, map_icons)

    def create_map_icons(self, map_icons: any) -> None:
        """
        Create map icons based on the provided mapping.

        Args:
            map_icons (any): The icons mapping.

        Returns:
            None
        """
        return self.mindm.create_map_icons(map_icons)

    def create_tags(self, tags: list[str], DUPLICATED_TAG: str) -> None:
        """
        Create tags for the mind map.

        Args:
            tags (list[str]): A list of tag names to create.
            DUPLICATED_TAG (str): The tag used in case of duplication.

        Returns:
            None
        """
        return self.mindm.create_tags(tags, DUPLICATED_TAG)

    def add_relationship(self, guid1: any, guid2: any, label: str = '') -> None:
        """
        Add a relationship between two topics.

        Args:
            guid1 (any): The GUID of the first topic.
            guid2 (any): The GUID of the second topic.
            label (str, optional): Optional label for the relationship. Defaults to ''.

        Returns:
            None
        """
        return self.mindm.add_relationship(guid1, guid2, label)

    def add_topic_link(self, guid1: any, guid2: any, label: str = '') -> None:
        """
        Create a link between two topics.

        Args:
            guid1 (any): The GUID of the source topic.
            guid2 (any): The GUID of the target topic.
            label (str, optional): Optional label for the link. Defaults to ''.

        Returns:
            None
        """
        return self.mindm.add_topic_link(guid1, guid2, label)

    def add_document(self, max_topic_level: int) -> None:
        """
        Add a new mind map document with a specified maximum topic level.

        Args:
            max_topic_level (int): The maximum depth of topics in the document.

        Returns:
            None
        """
        return self.mindm.add_document(max_topic_level)

    def finalize(self, max_topic_level: int) -> None:
        """
        Finalize and process the mind map document.

        Args:
            max_topic_level (int): The maximum depth of topics processed.

        Returns:
            None
        """
        return self.mindm.finalize(max_topic_level)


================================================
File: mindm/mindmanager_mac.py
================================================
"""
MacOS-specific implementation of the Mindmanager interface.

This module provides MacOS platform-specific implementation for interacting
with MindManager application, including functionality for manipulating topics,
properties, relationships, and document structure.
"""

import os
from appscript import *

from mindmap.mindmap import MindmapLink, MindmapImage, MindmapNotes, MindmapIcon, MindmapTag, MindmapReference

class Mindmanager:

    MACOS_MERGE_ALL_WINDOWS = False
    MACOS_LIBRARY_FOLDER = os.path.join(os.path.expanduser("~"), "Library", "Application Support", "Mindjet", "MindManager", "XX", "English", "Library")

    def __init__(self, charttype):
        self._mindmanager = app('MindManager')
        self._version = self._mindmanager.version.get().split('.')[0]
        self._master_window = self._mindmanager.windows[1].id.get()
        self._charttype = charttype
        self._library_folder = self.MACOS_LIBRARY_FOLDER.replace("XX", self._version)
        self._orgchart_template = mactypes.Alias(os.path.join(self._library_folder, "Templates", "Blank Templates", "Org-Chart Map.mmat"))
        self._radial_template = mactypes.Alias(os.path.join(self._library_folder, "Templates", "Blank Templates", "Radial Map.mmat"))

    def get_mindmanager_object(self):
        return self._mindmanager
        
    def get_active_document_object(self):
        if self.document_exists():
            return self._mindmanager.documents[1]
        return None
        
    def get_library_folder(self):
        return self._library_folder
    
    def get_version(self):
        return self._version

    def merge_windows(self):
        for window in self._mindmanager.windows():
            if window.id.get() == self._master_window:
                window.activate()
        system_events = app("System Events")
        system_events.processes["MindManager"].menu_bars[1].menu_bar_items["Window"].menus["Window"].menu_items["Merge All Windows"].click()

    def set_document_background_image(self, path):
        pass
    
    def document_exists(self):
        try:
            return self._mindmanager.documents[1].exists()
        except Exception as e:
            print(f"Error checking document existence: {e}")
            return False

    def get_central_topic(self):
        try:
            topic = self._mindmanager.documents[1].central_topic.get()
            #callouts = topic.callouts.get()
            #relationships = topic.relationships.get()
            #subtopics = topic.subtopics.get()
            #shape = topic.shape.get()
            #attributes = topic.attributes.get()
            #props = topic.properties.get()
            #task = topic.task.get()
            #task_properties = task.properties.get()
            return topic
        except Exception as e:
            print(f"Error getting central topic: {e}")
            return None
    
    def get_topic_by_id(self, id):
        try:
            found_topics = self._mindmanager.documents[1].topics[its.id == id]
            if found_topics.count() == 0:
                return None
            return found_topics[0].get()
        except Exception as e:
            print(f"Error getting topic by id: {e}")
            return None
    
    def get_selection(self):
        selection = []
        try:
            items = self._mindmanager.documents[1].selection.get()
            for item in items:
                type = item.class_.get()
                if type.name == 'topic':
                    selection.append(item)
        except Exception as e:
            print(f"Error getting selection: {e}")
        return selection
    
    def get_level_from_topic(self, topic):
        try:
            return topic.level.get()
        except Exception as e:
            print(f"Error getting level from topic: {e}")
            return None
    
    def get_text_from_topic(self, topic):
        try:
            text = topic.name.get()
            return text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        except Exception as e:
            print(f"Error getting text from topic: {e}")
            return ""
    
    def get_title_from_topic(self, topic):
        try:
            title = topic.title.get()
            return title
        except Exception as e:
            print(f"Error getting title from topic: {e}")
            return ""
    
    def get_subtopics_from_topic(self, topic):
        try:
            return topic.subtopics.get()
        except Exception as e:
            print(f"Error getting subtopics from topic: {e}")
            return []

    def get_links_from_topic(self, topic) -> list['MindmapLink']:
        return None
        # this results in a severe runtime error of MindManager
        link = topic.hyperlink_URL.get()
        # this has no effect
        label = topic.label.get()
        return MindmapLink(link=link, label=label) if label != '' else None

    def get_image_from_topic(self, topic) -> MindmapImage:
        return None

    def get_icons_from_topic(self, topic) -> list[MindmapIcon]:
        return []

    def get_notes_from_topic(self, topic) -> MindmapNotes:
        try:
            notes = topic.notes.get()
            return MindmapNotes(text=notes)
        except Exception as e:
            print(f"Error getting notes from topic: {e}")
            return None

    def get_tags_from_topic(self, topic) -> list[MindmapTag]:
        return []

    def get_references_from_topic(self, topic) -> list[MindmapReference]:
        references = []
        try:
            relationships = topic.relationships.get()
            for relationship in relationships:
                relationship_instance = relationship.get()
                starting_location = relationship_instance.starting_location.get()
                ending_location = relationship_instance.ending_location.get()
                if starting_location == topic:
                    references.append(MindmapReference(
                        direction=1,
                        guid_1=starting_location.id.get(),
                        guid_2=ending_location.id.get()
                    ))
        except Exception as e:
            print(f"Error in get_references_from_topic: {e}")
        return references

    def get_guid_from_topic(self, topic) -> str:
        try:
            return topic.id.get()
        except Exception as e:
            print(f"Error in get_guid_from_topic: {e}")
            return ""
        
    def add_subtopic_to_topic(self, topic, topic_text):
        try:
            topic_instance = topic.get()
            return topic_instance.subtopics.end.make(new=k.topic, with_properties={k.name: topic_text})
        except Exception as e:
            print(f"Error in add_subtopic_to_topic: {e}")
            return None

    def get_parent_from_topic(self, topic):
        try:
            return topic.parent.get()
        except Exception as e:
            print(f"Error in get_parent_from_topic: {e}")
            return None

    def set_text_to_topic(self, topic, topic_text):
        try:
            topic.name.set(topic_text)
        except Exception as e:
            print(f"Error in set_text_to_topic: {e}")

    def set_title_to_topic(self, topic, topic_rtf):
        try:
            topic.title.set(topic_rtf)
        except Exception as e:
            print(f"Error in set_title_to_topic: {e}")

    def add_tag_to_topic(self, topic, tag_text, topic_guid):
        pass

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons):
        try:
            topic_id = topic.id.get()
            self.set_text_to_topic(topic, mindmap_topic.text)
            refreshed_topic = self.get_topic_by_id(topic_id)
            if mindmap_topic.rtf != '':
                self.set_title_to_topic(refreshed_topic, mindmap_topic.rtf)
                refreshed_topic = self.get_topic_by_id(topic_id)
            if mindmap_topic.notes:
                refreshed_topic.notes.set(mindmap_topic.notes.text)
                refreshed_topic = self.get_topic_by_id(topic_id)
            return refreshed_topic, topic_id
        except Exception as e:
            print(f"Error in set_topic_from_mindmap_topic: {e}")
            return None, None

    def create_map_icons(self, map_icons):
        pass

    def create_tags(self, tags: list['str'], DUPLICATED_TAG: str):
        pass

    def add_relationship(self, guid1, guid2, label = ''):
        try:
            topic1 = self.get_topic_by_id(guid1)
            topic2 = self.get_topic_by_id(guid2)
            if topic1 is None or topic2 is None:
                print("Error in add_relationship: One or both topics not found.")
                return
            topic1.make(new=k.relationship, with_properties={k.starting_location: topic1, k.ending_location: topic2})
        except Exception as e:
            print(f"Error in add_relationship: {e}")

    def add_topic_link(self, guid1, guid2, label=''):
        pass

    def add_document(self, max_topic_level):
        cnt_subtopics = len(self._mindmanager.documents[1].central_topic.subtopics.get())
        if self._charttype == "orgchart":
            template_alias = self._orgchart_template
        if self._charttype == "radial":
            template_alias = self._radial_template
        if self._charttype == "auto":
            if max_topic_level > 2 and cnt_subtopics > 4:
                template_alias = self._orgchart_template
            else:
                template_alias = self._radial_template
        self._mindmanager.open(template_alias)

    def finalize(self, max_topic_level):
        self._mindmanager.documents[1].balance_map()
        self._mindmanager.activate()
        if self.MACOS_MERGE_ALL_WINDOWS:
            self.merge_windows()
        self._mindmanager = None
        del self._mindmanager



================================================
File: mindm/mindmanager_win.py
================================================
"""
Windows-specific implementation of the Mindmanager interface.

This module provides Windows platform-specific implementation for interacting
with MindManager application, including functionality for manipulating topics,
properties, relationships, and document structure.
"""

import os
import win32com.client
import winreg
import tempfile

from mindmap.mindmap import MindmapLink, MindmapImage, MindmapNotes, MindmapIcon, MindmapTag, MindmapReference

class Mindmanager:

    @staticmethod
    def get_mindmanager_version():
        versions = ["26", "25", "24", "23"]
        for version in versions:
            try:
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, f"Software\\Mindjet\\MindManager\\{version}\\AddIns")
                winreg.CloseKey(key)
                return version
            except FileNotFoundError:
                continue
        return None

    mindmanager_version = get_mindmanager_version()
    if mindmanager_version:
        WINDOWS_LIBRARY_FOLDER = os.path.join(os.environ.get("LOCALAPPDATA", ""), "Mindjet", "MindManager", mindmanager_version, "Library", "ENU")
    else:
        raise Exception("No MindManager version registry keys found.")

    def __init__(self, charttype):
        self._version = Mindmanager.get_mindmanager_version()
        self._mindmanager = win32com.client.Dispatch("Mindmanager.Application")
        self._mindmanager.Options.BalanceNewMainTopics = True
        self._charttype = charttype
        self._library_folder = self.WINDOWS_LIBRARY_FOLDER
        self._document = self._mindmanager.ActiveDocument
    
    def get_mindmanager_object(self):
        return self._mindmanager
        
    def get_active_document_object(self):
        return self._mindmanager.ActiveDocument
        
    def get_library_folder(self):
        return self._library_folder

    def get_version(self):
        return self._version

    def set_document_background_image(self, path):
        try:
            background = self._document.Background
            if background.HasImage:
                background.RemoveImage()
            background.InsertImage(path)
            background.TileOption = 1  # center
            background.Transparency = 88
        except Exception as e:
            print(f"Error setting document background image: {e}")

    def document_exists(self):
        try:
            return True if self._document else False
        except Exception as e:
            print(f"Error checking document existence: {e}")
            return False

    def get_central_topic(self):
        try:
            return self._document.CentralTopic
        except Exception as e:
            raise Exception(f"Error getting central topic: {e}")
    
    def get_topic_by_id(self, id):
        try:
            return self._document.FindByGuid(id)
        except Exception as e:
            print(f"Error in get_topic_by_id: {e}")
            return None

    def get_selection(self):
        selection = []
        try:
            objs = self._document.Selection
            for obj in objs:
                try:
                    class_name = obj._oleobj_.GetTypeInfo().GetDocumentation(-1)[0]
                    if class_name == "ITopic":
                        selection.append(obj)
                except Exception as e:
                    print(f"Error in get_selection, getting class name: {e}")
                    continue
        except Exception as e:
            print(f"Error in get_selection: {e}")
        return selection

    def get_level_from_topic(self, topic):
        try:
            return topic.Level
        except Exception as e:
            print(f"Error in get_level_from_topic: {e}")
            return None

    def get_text_from_topic(self, topic):
        try:
            return topic.Text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        except Exception as e:
            print(f"Error in get_text_from_topic: {e}")
            return ""

    def get_title_from_topic(self, topic):
        try:
            title = topic.Title
            text = title.TextRTF if title.TextRTF != '' else ''
            return text
        except Exception as e:
            print(f"Error in get_title_from_topic: {e}")
            return ""

    def get_subtopics_from_topic(self, topic):
        try:
            return topic.AllSubTopics
        except Exception as e:
            print(f"Error in get_subtopics_from_topic: {e}")
            return None
    
    def get_links_from_topic(self, topic) -> list[MindmapLink]:
        hyperlinks = []
        try:
            if topic.HasHyperlink:
                for hyperlink in topic.Hyperlinks:
                    link = MindmapLink(
                        text=hyperlink.Title,
                        url=hyperlink.Address,
                        guid=hyperlink.TopicLabelGuid
                    )
                    hyperlinks.append(link)
        except Exception as e:
            print(f"Error in get_links_from_topic: {e}")
        return hyperlinks

    def get_image_from_topic(self, topic) -> MindmapImage:
        try:
            if topic.HasImage:
                image = topic.Image
                with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp:
                    temp_filename = tmp.name
                image.Save(temp_filename, 3)  # 3=PNG
                return MindmapImage(text=temp_filename)
        except Exception as e:
            print(f"Error in get_image_from_topic: {e}")
        return None

    def get_icons_from_topic(self, topic) -> list[MindmapIcon]:
        icons = []
        try:
            user_icons = topic.UserIcons
            if user_icons.Count > 0:
                for icon in user_icons:
                    if icon.Type == 1 and icon.IsValid == True:  # Stock Icon
                        icons.append(MindmapIcon(
                            text=icon.Name,
                            index=icon.StockIcon
                        ))
                    elif icon.Type == 2 and icon.IsValid == True:
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp:
                            temp_filename = tmp.name
                        icon.Save(temp_filename, 3)  # 3=PNG
                        icons.append(MindmapIcon(
                            text=icon.Name,
                            is_stock_icon=False,
                            signature=icon.CustomIconSignature,
                            path=temp_filename
                        ))
        except Exception as e:
            print(f"Error in get_icons_from_topic: {e}")
        return icons

    def get_notes_from_topic(self, topic) -> MindmapNotes:
        try:
            notes = topic.Notes
            topic_notes = None
            if notes:
                if notes.IsValid == True and not notes.IsEmpty:
                    topic_notes = MindmapNotes()
                    if notes.TextRTF != "":
                        topic_notes.rtf = notes.TextRTF
                    if notes.TextXHTML != "":
                        topic_notes.xhtml = notes.TextXHTML
                    if notes.Text != "":
                        topic_notes.text = notes.Text
            return topic_notes
        except Exception as e:
            print(f"Error in get_notes_from_topic: {e}")
            return None

    def get_tags_from_topic(self, topic) -> list[MindmapTag]:
        tags = []
        try:
            text_labels = topic.TextLabels
            if text_labels.Count > 0 and text_labels.IsValid == True:
                for text_label in text_labels:
                    if text_label.IsValid == True and text_label.GroupId == "":
                        tags.append(MindmapTag(text=text_label.Name))
        except Exception as e:
            print(f"Error in get_tags_from_topic: {e}")
        return tags

    def get_references_from_topic(self, topic) -> list[MindmapReference]:
        references = []
        try:
            relationships = topic.AllRelationships
            if relationships.Count > 0 and relationships.IsValid == True:
                for relation in relationships:
                    if relation.IsValid == True:
                        connected_topic_guid_1 = relation.ConnectedObject1
                        connected_topic_guid_2 = relation.ConnectedObject2
                        reference_direction = 1 if connected_topic_guid_1 == topic else 2
                        references.append(MindmapReference(
                            guid_1=str(connected_topic_guid_1.Guid),
                            guid_2=str(connected_topic_guid_2.Guid),
                            direction=reference_direction,
                            label=''
                        ))
        except Exception as e:
            print(f"Error in get_references_from_topic: {e}")
        return references
    
    def get_guid_from_topic(self, topic) -> str:
        try:
            return topic.Guid
        except Exception as e:
            print(f"Error in get_guid_from_topic: {e}")
            return ""
        
    def add_subtopic_to_topic(self, topic, topic_text):
        try:
            return topic.AddSubtopic(topic_text)
        except Exception as e:
            print(f"Error in add_subtopic_to_topic: {e}")
            return None

    def get_parent_from_topic(self, topic):
        try:
            return topic.ParentTopic
        except Exception as e:
            print(f"Error in get_parent_from_topic: {e}")
            return None

    def set_text_to_topic(self, topic, topic_text):
        try:
            topic.Text = topic_text
        except Exception as e:
            print(f"Error in set_text_to_topic: {e}")

    def set_title_to_topic(self, topic, topic_rtf):
        try:
            if topic_rtf != "":
                topic.Title.TextRTF = topic_rtf
        except Exception as e:
            print(f"Error in set_title_to_topic: {e}")

    def add_tag_to_topic(self, topic=None, tag_text='', topic_guid=None):
        try:
            if topic_guid:
                topic = self.get_topic_by_id(topic_guid)
            if topic:
                topic.TextLabels.AddTextLabelFromGroup(tag_text, '', True)
        except Exception as e:
            print(f"Error in add_tag_to_topic: {e}")

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons):
        self.set_text_to_topic(topic, mindmap_topic.text)
        self.set_title_to_topic(topic, mindmap_topic.rtf)
        self.add_tags_to_topic(topic, mindmap_topic.tags)
        self.set_notes_to_topic(topic, mindmap_topic.notes)
        self.add_icons_to_topic(topic, mindmap_topic.icons, map_icons)
        self.add_image_to_topic(topic, mindmap_topic.image)
        self.add_links_to_topic(topic, mindmap_topic.links)
        return topic, topic.Guid
    
    def add_links_to_topic(self, topic, mindmap_topic_links):
        try:
            if mindmap_topic_links:
                for topic_link in mindmap_topic_links:
                    if topic_link.guid == "" and topic_link.url != "":
                        link = topic.Hyperlinks.AddHyperlink(topic_link.url)
                        link.Title = topic_link.text
        except Exception as e:
            print(f"Error in add_links_to_topic: {e}")

    def add_image_to_topic(self, topic, mindmap_topic_image):
        try:
            if mindmap_topic_image:
                topic.CreateImage(mindmap_topic_image.text)
        except Exception as e:
            print(f"Error in add_image_to_topic: {e}")

    def add_icons_to_topic(self, topic, mindmap_topic_icons, map_icons):
        try:
            if len(mindmap_topic_icons) > 0:
                for topic_icon in mindmap_topic_icons:
                    if topic_icon.is_stock_icon:
                        topic.UserIcons.AddStockIcon(topic_icon.index)
                    else:
                        if len(map_icons) > 0 and topic_icon.signature != "":
                            topic.UserIcons.AddCustomIconFromMap(topic_icon.signature)
                        else:
                            if os.path.exists(topic_icon.path):
                                topic.UserIcons.AddCustomIcon(topic_icon.path)
        except Exception as e:
            print(f"Error in add_icons_to_topic: {e}")

    def set_notes_to_topic(self, topic, mindmap_topic_notes):
        try:
            if mindmap_topic_notes:
                if mindmap_topic_notes.text:
                    topic.Notes.Text = mindmap_topic_notes.text
                else:
                    if mindmap_topic_notes.xhtml:
                        try:
                            topic.Notes.TextXHTML = mindmap_topic_notes.xhtml
                        except Exception as e:
                            print(f"Error setting TextXHTML: {e}")
                            print(f"Topic: `{topic.Text}`")
                    else:
                        if mindmap_topic_notes.rtf:
                            topic.Notes.TextRTF = mindmap_topic_notes.rtf
        except Exception as e:
            print(f"Error in set_notes_to_topic: {e}")


    def add_tags_to_topic(self, topic, mindmap_topic_tags):
        try:
            if len(mindmap_topic_tags) > 0:
                for topic_tag in mindmap_topic_tags:
                    topic.TextLabels.AddTextLabelFromGroup(topic_tag.text, '', True)
        except Exception as e:
            print(f"Error in add_tags_to_topic: {e}")

    def create_map_icons(self, map_icons):
        try:
            if len(map_icons) > 0:
                icon_groups = set(map_icon.group for map_icon in map_icons if map_icon.group)
                for icon_group in icon_groups:
                    group = self._document.MapMarkerGroups.AddIconMarkerGroup(icon_group)
                    for map_icon in map_icons:
                        if map_icon.group == icon_group:
                            label = map_icon.text
                            marker = group.AddCustomIconMarker(label, map_icon.path)
                            map_icon.signature = marker.Icon.CustomIconSignature
        except Exception as e:
            print(f"Error in create_map_icons: {e}")

    def create_tags(self, tags: list['str'], DUPLICATED_TAG: str):
        try:
            if len(tags) > 0:
                map_marker_group = self._document.MapMarkerGroups.GetMandatoryMarkerGroup(10)
                for tag in tags:
                    map_marker_group.AddTextLabelMarker(tag)
                if DUPLICATED_TAG != '' and DUPLICATED_TAG not in tags:
                    map_marker_group.AddTextLabelMarker(DUPLICATED_TAG)
        except Exception as e:
            print(f"Error in create_tags: {e}")

    def add_relationship(self, guid1, guid2, label=''):
        try:
            object1 = self.get_topic_by_id(guid1)
            object2 = self.get_topic_by_id(guid2)
            if object1 and object2:
                if object1.ParentTopic == object2 or object2.ParentTopic == object1:
                    return
                object1.AllRelationships.AddToTopic(object2, label)
        except Exception as e:
            print(f"Error in add_relationship: {e}")

    def add_topic_link(self, guid1, guid2, label=''):
        try:
            object1 = self.get_topic_by_id(guid1)
            object2 = self.get_topic_by_id(guid2)
            if object1 and object2:
                hyperlinks = object1.Hyperlinks
                link = hyperlinks.AddHyperlinkToTopicByGuid(guid2)
                link.Title = label if label != "" else object2.Title.Text
        except Exception as e:
            print(f"Error in add_topic_link: {e}")

    def add_document(self, max_topic_level):
        try:
            style = self._document.StyleXml
            new_document = self._mindmanager.Documents.Add()
            new_document.StyleXml = style
            self._document = new_document
        except Exception as e:
            print(f"Error in add_document: {e}")

    def finalize(self, max_topic_level):
        try:
            centralTopic = self._document.CentralTopic
            layout = centralTopic.SubTopicsLayout
            growthDirection = layout.CentralTopicGrowthDirection
            cnt_subtopics = len(centralTopic.AllSubTopics)
                               
            # collapse/uncollapse outer topics
            if max_topic_level > 3:
                for topic in self._document.Range(2, True):  # 2 = all topics
                    if topic.Level > 2:
                        topic.Collapsed = True
                    else:
                        if topic.Level != 0:
                            topic.Collapsed = False
            else:
                for topic in self._document.Range(2, True):  # 2 = all topics
                    if topic.Level > 3:
                        topic.Collapsed = True
                    else:
                        if topic.Level != 0:
                            topic.Collapsed = False
                            
            # org chart            
            if self._charttype == "orgchart" or self._charttype == "auto":
                if max_topic_level > 2 and cnt_subtopics > 4:
                    if growthDirection == 1:
                        layout.CentralTopicGrowthDirection = 5
                        
            # radial map
            if self._charttype == "radial" or self._charttype == "auto":
                if max_topic_level > 2 and cnt_subtopics < 5:
                    if growthDirection != 1:
                        layout.CentralTopicGrowthDirection = 1
                if max_topic_level < 3 and cnt_subtopics > 4:
                    if growthDirection != 1:
                        layout.CentralTopicGrowthDirection = 1

            self._document.Zoom(1)
            self._mindmanager.Visible = True
        except Exception as e:
            print(f"Error in finalize: {e}")


================================================
File: mindmap/__init__.py
================================================
# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"



================================================
File: mindmap/export.py
================================================



================================================
File: mindmap/helpers.py
================================================
import re

def escape_mermaid_text(text: str) -> str:
    """Escape special characters in text for Mermaid compatibility.
    
    Args:
        text (str): Text to escape
        
    Returns:
        str: Escaped text for use in Mermaid diagrams
    """
    if not isinstance(text, str):
        return text
    escaped = text.replace("\\", "\\\\") \
                  .replace("\n", "\\n") \
                  .replace("\r", "") \
                  .replace("\"", "\\\"")
    result = []
    for ch in escaped:
        if ord(ch) > 127:
            result.append("\\u{:04x}".format(ord(ch)))
        else:
            result.append(ch)
    return "".join(result)

def replace_unicode_for_markdown(text: str) -> str:
    """Replace Unicode characters for compatibility with Markdown.
    
    Args:
        text (str): Text containing Unicode characters
        
    Returns:
        str: Text with Unicode characters replaced for Markdown compatibility
    """
    return text

def replace_unicode_in_obj(obj):
    """Recursively replace Unicode characters in an object.
    
    Args:
        obj: Object potentially containing Unicode strings
        
    Returns:
        object: Object with Unicode characters replaced
    """
    if isinstance(obj, str):
        return replace_unicode_for_markdown(obj)
    elif isinstance(obj, list):
        return [replace_unicode_in_obj(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: replace_unicode_in_obj(value) for key, value in obj.items()}
    else:
        return obj



================================================
File: mindmap/import.py
================================================



================================================
File: mindmap/mindmap.py
================================================
import uuid

import mindm.mindmanager as mm

DUPLICATED_TAG = 'Duplicated'
DUPLICATE_LABEL = 'DUPLICATE'

class MindmapLink:
    def __init__(self, text: str = '', url: str = '', guid: str = ''):
        """
        Initialize a MindmapLink instance.

        Args:
            text (str): The display text for the link.
            url (str): The URL that the link points to.
            guid (str): A unique identifier for the link.
        """
        self.text = text
        self.url = url
        self.guid = guid

class MindmapImage:
    def __init__(self, text: str = ''):
        """
        Initialize a MindmapImage instance.

        Args:
            text (str): Path to the image.
        """
        self.text = text

class MindmapNotes:
    def __init__(self, text: str = '', xhtml: str = '', rtf: str = ''):
        """
        Initialize a MindmapNotes instance.

        Args:
            text (str): Plain text version of the notes.
            xhtml (str): XHTML formatted notes.
            rtf (str): RTF formatted notes.
        """
        self.text = text
        self.xhtml = xhtml
        self.rtf = rtf

class MindmapIcon:
    def __init__(self, 
                 text: str = '', 
                 is_stock_icon=True, 
                 index: int = 1, 
                 signature: str = '', 
                 path: str = '',
                 group: str = ''):
        """
        Initialize a MindmapIcon instance.

        Args:
            text (str): The display text for the icon.
            is_stock_icon (bool): Flag indicating if the icon is a stock icon.
            index (int): The index of a stock icon.
            signature (str): A unique signature for the icon.
            path (str): File path to the icon if it is custom.
            group (str): The group/category of the icon.
        """
        self.text = text
        self.is_stock_icon = is_stock_icon
        self.index = index
        self.signature = signature
        self.path = path
        self.group = group

class MindmapTag:
    def __init__(self, text: str = ''):
        """
        Initialize a MindmapTag instance.

        Args:
            text (str): The text representing the tag.
        """
        self.text = text

class MindmapReference:
    def __init__(self, 
                 guid_1: str = '', 
                 guid_2: str = '', 
                 direction: int = 1, 
                 label: str = ''):
        """
        Initialize a MindmapReference (relationship) instance.

        Args:
            guid_1 (str): The GUID of the first topic.
            guid_2 (str): The GUID of the second topic.
            direction (int): The direction of the reference (1 indicates a standard direction).
            label (str): A label for the relationship.
        """
        self.guid_1 = guid_1
        self.guid_2 = guid_2
        self.direction = direction
        self.label = label

class MindmapTopic:
    def __init__(self,
                 guid: str = '',
                 text: str = '',
                 rtf: str = '',
                 level: int = 0,
                 selected: bool = False,
                 parent: 'MindmapTopic' = None,
                 subtopics: list['MindmapTopic'] = None,
                 links: list['MindmapLink'] = None,
                 image: 'MindmapImage' = None,
                 icons: list['MindmapIcon'] = None,
                 notes: 'MindmapNotes' = None,
                 tags: list['MindmapTag'] = None,
                 references: list['MindmapReference'] = None):
        """
        Initialize a MindmapTopic instance.

        Args:
            guid (str): Unique identifier for the topic.
            text (str): The text content of the topic.
            rtf (str): RTF formatted text for the topic.
            level (int): The hierarchical level of the topic.
            selected (bool): Flag to indicate if the topic is selected.
            parent (MindmapTopic): The parent topic if any.
            subtopics (list[MindmapTopic]): List of subtopics.
            links (list[MindmapLink]): List of associated links.
            image (MindmapImage): Associated image object.
            icons (list[MindmapIcon]): List of associated icons.
            notes (MindmapNotes): Associated notes.
            tags (list[MindmapTag]): List of associated tags.
            references (list[MindmapReference]): List of associated relationships.
        """
        self.guid = guid
        self.text = text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        self.rtf = rtf
        self.level = level
        self.selected = selected
        self.parent = parent
        self.links = links if links is not None else []
        self.image = image
        self.icons = icons if icons is not None else []
        self.notes = notes
        self.tags = tags if tags is not None else []
        self.references = references if references is not None else []
        self.subtopics = subtopics if subtopics is not None else []


class MindmapDocument:
    def __init__(self, charttype: str = 'auto', turbo_mode: bool = False, inline_editing_mode: bool = False, mermaid_mode: bool = True):
        """
        Initialize a MindmapDocument instance which automates MindManager operations.

        Args:
            charttype (str): The type of chart to be used (orgchart, radial, auto).
            turbo_mode (bool): Flag for enabling turbo mode -> use only text.
            inline_editing_mode (bool): Flag for enabling inline editing mode.
            mermaid_mode (bool): Flag for enabling mermaid mode.
        """
        self.charttype: str = charttype
        self.turbo_mode: bool = turbo_mode
        self.inline_editing_mode: bool = inline_editing_mode
        self.mermaid_mode: bool = mermaid_mode
        self.mindmap: 'MindmapTopic' = None
        self.central_topic_selected: bool = False
        self.selected_topic_texts: list[str] = []
        self.selected_topic_levels: list[int] = []
        self.selected_topic_ids: list[str] = []
        self.max_topic_level: int = 0

        self.mindm = mm.Mindmanager(charttype)

    def get_mindmap(self, topic=None, mode='full'):
        """
        Retrieve the mind map structure from the currently open MindManager document.

        Args:
            topic: (Optional) A specific topic from which to start building the mindmap.
                   If not provided, the central topic is used.
            mode (str): The mode to use to gather attributes (full=all attributes, content=text+rtf+notes, text=text only).

        Returns:
            bool: True if the mind map was successfully retrieved, otherwise False.
        """
        if not self.mindm.document_exists():
            print("No document found. Please open MindManager with a document.")    
            return False

        if topic is None:
            topic = self.mindm.get_central_topic()
        
        # Build the mindmap topic structure from the provided topic
        mindmap = self.get_mindmap_topic_from_topic(topic, mode=mode)

        # Retrieve the current selection information
        selection = self.get_selection()
        selected_topic_texts, selected_topic_levels, selected_topic_ids, central_topic_selected = self.get_topic_texts_from_selection(selection)
        self.central_topic_selected = central_topic_selected
        self.selected_topic_texts = selected_topic_texts
        self.selected_topic_levels = selected_topic_levels
        self.selected_topic_ids = selected_topic_ids
        self.max_topic_level = self.get_max_topic_level(mindmap)
        self.mindmap = mindmap
        return True
    
    def get_max_topic_level(self, mindmap_topic, max_topic_level=0, visited=None):
        """
        Recursively compute the maximum topic level within the mind map.

        Args:
            mindmap_topic (MindmapTopic): The current topic to evaluate.
            max_topic_level (int): The current maximum level found.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.

        Returns:
            int: The highest topic level found in the mindmap.
        """
        if visited is None:
            visited = set()
        if mindmap_topic.guid in visited:
            return max_topic_level
        visited.add(mindmap_topic.guid)
        for subtopic in mindmap_topic.subtopics:
            if subtopic.level > max_topic_level:
                max_topic_level = subtopic.level
            max_topic_level = self.get_max_topic_level(subtopic, max_topic_level, visited)
        return max_topic_level

    def get_parent_topic(self, topic):
        """
        Retrieve the parent topic for a given MindManager topic.

        Args:
            topic: The current topic from which to get the parent.

        Returns:
            MindmapTopic or None: The parent topic wrapped as a MindmapTopic, or None if at the root.
        """
        topic_level = self.mindm.get_level_from_topic(topic)
        if topic_level == 0:
            return None
        parent_topic = self.mindm.get_parent_from_topic(topic)
        parent_mindmap_topic = MindmapTopic(
            guid=self.mindm.get_guid_from_topic(parent_topic),
            text=self.mindm.get_text_from_topic(parent_topic), 
            level=self.mindm.get_level_from_topic(parent_topic),
            parent=self.get_parent_topic(parent_topic),
        )
        return parent_mindmap_topic

    def get_selection(self):
        """
        Retrieve the currently selected topics in the MindManager document.

        Returns:
            list[MindmapTopic]: A list of MindmapTopic instances representing the selection.
        """
        selection = self.mindm.get_selection()
        mindmap_topics = []
        for topic in selection:
            level = self.mindm.get_level_from_topic(topic)
            mindmap_topic = MindmapTopic(
                guid=self.mindm.get_guid_from_topic(topic),
                text=self.mindm.get_text_from_topic(topic), 
                level=level,
                parent=self.get_parent_topic(topic),
                selected=True,
            )
            mindmap_topics.append(mindmap_topic)
        return mindmap_topics

    def get_mindmap_topic_from_topic(self, topic, parent_topic=None, mode='full'):
        """
        Recursively convert a MindManager topic into a MindmapTopic object.

        Args:
            topic: The current MindManager topic to convert.
            parent_topic (MindmapTopic): The parent MindmapTopic, if any.
            mode (str): The mode to use to gather attributes (full=all attributes, content=text+rtf+notes, text=text only).

        Returns:
            MindmapTopic: The converted topic with its subtopics.
        """
        mindmap_topic = MindmapTopic(
            guid=self.mindm.get_guid_from_topic(topic),
            text=self.mindm.get_text_from_topic(topic),
            rtf=self.mindm.get_title_from_topic(topic),
            level=self.mindm.get_level_from_topic(topic),
            parent=parent_topic
        )

        if mode == 'full':
            mindmap_topic.links = self.mindm.get_links_from_topic(topic)
            mindmap_topic.image = self.mindm.get_image_from_topic(topic)
            mindmap_topic.icons = self.mindm.get_icons_from_topic(topic)
            mindmap_topic.notes = self.mindm.get_notes_from_topic(topic)
            mindmap_topic.tags = self.mindm.get_tags_from_topic(topic)
            mindmap_topic.references = self.mindm.get_references_from_topic(topic)

        if mode == 'content':
            mindmap_topic.notes = self.mindm.get_notes_from_topic(topic)

        subtopics = self.mindm.get_subtopics_from_topic(topic)
        mindmap_subtopics = []
        for subtopic in subtopics:
            child = self.get_mindmap_topic_from_topic(subtopic, parent_topic=mindmap_topic, mode=mode)
            mindmap_subtopics.append(child)
        mindmap_topic.subtopics = mindmap_subtopics
        return mindmap_topic 

    def get_relationships_from_mindmap(self, mindmap, references, visited=None):
        """
        Recursively extract relationships (references) from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            references (list[MindmapReference]): List to collect the relationships.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for reference in mindmap.references:
            if reference.direction == 1:
                references.append(MindmapReference(
                    guid_1=reference.guid_1,
                    guid_2=reference.guid_2,
                    direction=reference.direction,
                    label=reference.label
                ))
        for subtopic in mindmap.subtopics:
            self.get_relationships_from_mindmap(subtopic, references, visited)

    def get_topic_links_from_mindmap(self, mindmap, links, visited=None):
        """
        Recursively extract topic links from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            links (list[MindmapReference]): List to collect topic links as MindmapReference objects.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for link in mindmap.links:
            if link.guid != '':
                links.append(MindmapReference(
                    guid_1=mindmap.guid, 
                    guid_2=link.guid, 
                    direction=1, 
                    label=link.text
                ))
        for subtopic in mindmap.subtopics:
            self.get_topic_links_from_mindmap(subtopic, links, visited)

    def get_tags_from_mindmap(self, mindmap, tags, visited=None):
        """
        Recursively collect unique tags from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            tags (list[str]): List to collect tag texts.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for tag in mindmap.tags:
            if tag.text != '' and tag.text not in tags:
                tags.append(tag.text)
        for subtopic in mindmap.subtopics:
            self.get_tags_from_mindmap(subtopic, tags, visited)

    def get_parents_from_mindmap(self, mindmap, parents, visited=None):
        """
        Build a dictionary mapping subtopic GUIDs to their parent's GUID.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            parents (dict): Dictionary to store parent-child GUID mappings.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for subtopic in mindmap.subtopics:
            if subtopic.guid not in parents:
                parents[subtopic.guid] = mindmap.guid
                self.get_parents_from_mindmap(subtopic, parents, visited)
        return

    def get_map_icons_and_fix_refs_from_mindmap(self, mindmap, map_icons: list['MindmapIcon'], visited=None):
        """
        Extract icons from mindmap topics and fix their references if needed.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            map_icons (list[MindmapIcon]): List to collect unique icons.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        
        for i, topic_icon_ref in enumerate(mindmap.icons):
            # Only process non-stock icons belonging to the 'Types' group
            if not topic_icon_ref.is_stock_icon and topic_icon_ref.group == 'Types':
                found = False
                for map_icon in map_icons:
                    if map_icon.signature == topic_icon_ref.signature:
                        found = True
                        new_icon = map_icon
                        break
                if not found:
                    new_icon = MindmapIcon(
                        text=topic_icon_ref.text, 
                        index=topic_icon_ref.index,
                        is_stock_icon=topic_icon_ref.is_stock_icon, 
                        path=topic_icon_ref.path,
                        signature=topic_icon_ref.signature,
                        group=topic_icon_ref.group)                
                    map_icons.append(new_icon)
                mindmap.icons[i] = new_icon
        for subtopic in mindmap.subtopics:
            self.get_map_icons_and_fix_refs_from_mindmap(subtopic, map_icons, visited)

    def count_parent_and_child_occurrences(self, mindmap_topic, guid_counts, visited=None):
        """
        Recursively count the occurrences of parent and child relationships for each topic.

        Args:
            mindmap_topic (MindmapTopic): The current topic in the mindmap.
            guid_counts (dict): Dictionary to store counts with topic GUID as keys.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if str(mindmap_topic.guid) == '':
            mindmap_topic.guid = str(uuid.uuid4())
        if mindmap_topic.guid not in visited:
            visited.add(mindmap_topic.guid)
            if mindmap_topic.guid not in guid_counts:
                guid_counts[mindmap_topic.guid] = {'parent': 0, 'child': 0}
            for subtopic in mindmap_topic.subtopics:
                if mindmap_topic.guid:
                    guid_counts[mindmap_topic.guid]['parent'] += 1
                if subtopic.guid:
                    if subtopic.guid not in guid_counts:
                        guid_counts[subtopic.guid] = {'parent': 0, 'child': 0}
                    guid_counts[subtopic.guid]['child'] += 1
                self.count_parent_and_child_occurrences(subtopic, guid_counts, visited)

    def get_topic_texts_from_selection(self, mindmap_topics):
        """
        Extract topic texts, levels, and GUIDs from selected topics.

        Args:
            mindmap_topics (list[MindmapTopic]): List of topics to process.

        Returns:
            tuple: (list of topic texts, list of topic levels, list of topic GUIDs, bool indicating if the central topic is selected)
        """
        topic_texts = []
        topic_levels = []
        topic_ids = []
        central_topic_selected = False
        for topic in mindmap_topics:
            if topic.selected:
                if topic.level > 0:
                    topic_texts.append(topic.text)
                    topic_levels.append(topic.level)
                    topic_ids.append(topic.guid)
                else:
                    central_topic_selected = True
        return topic_texts, topic_levels, topic_ids, central_topic_selected
            
    def clone_mindmap_topic(self, mindmap_topic, subtopics: list['MindmapTopic'] = None, parent=None):
        """
        Clone a MindmapTopic instance including its subtopics.

        Args:
            mindmap_topic (MindmapTopic): The topic to clone.
            subtopics (list[MindmapTopic], optional): A list of subtopics to clone.
            parent: The parent for the cloned topic.

        Returns:
            MindmapTopic: A new instance that is a clone of the given topic.
        """
        cloned_subtopics = []
        if subtopics is not None:
            for subtopic in subtopics:
                cloned_subtopic = self.clone_mindmap_topic(subtopic)
                cloned_subtopics.append(cloned_subtopic)
        return MindmapTopic(
            guid=mindmap_topic.guid,
            text=mindmap_topic.text, 
            rtf=mindmap_topic.rtf,
            level=mindmap_topic.level,
            parent=parent,
            links=mindmap_topic.links,
            image=mindmap_topic.image,
            icons=mindmap_topic.icons,
            notes=mindmap_topic.notes,
            tags=mindmap_topic.tags,
            subtopics=cloned_subtopics
        )

    def update_done(self, topic_guid, mindmap_topic, level, done, done_global):
        """
        Update tracking dictionaries for processed topics and create duplicate links/tags.

        Args:
            topic_guid (str): The GUID of the current topic in MindManager.
            mindmap_topic (MindmapTopic): The MindmapTopic being processed.
            level (int): The current level in the topic hierarchy.
            done (dict): Dictionary tracking topics processed at a given level.
            done_global (dict): Global dictionary tracking processed topics for duplicate detection.
        """
        if mindmap_topic.guid == '':
            return
        if level <= 1:
            done = {}
        elif level >= 2: 
            done[mindmap_topic.guid] = [topic_guid] if mindmap_topic.guid not in done else done[mindmap_topic.guid] + [topic_guid]
        if mindmap_topic.guid in done_global:
            # Check for duplicate relationships and add links/tags accordingly.
            if self.guid_counts[mindmap_topic.guid]['child'] < 11 and self.guid_counts[mindmap_topic.guid]['parent'] >= 0:
                for i in range(len(done_global[mindmap_topic.guid])):
                    link_from = topic_guid
                    link_to = done_global[mindmap_topic.guid][i]
                    self.mindm.add_topic_link(link_from, link_to, DUPLICATE_LABEL)
                    self.mindm.add_topic_link(link_to, link_from, DUPLICATE_LABEL)
                if len(done_global[mindmap_topic.guid]) == 1:
                    self.mindm.add_tag_to_topic(topic=None, tag_text=DUPLICATED_TAG, topic_guid=done_global[mindmap_topic.guid][0])
            self.mindm.add_tag_to_topic(topic=None, tag_text=DUPLICATED_TAG, topic_guid=topic_guid)
            done_global[mindmap_topic.guid] = done_global[mindmap_topic.guid] + [topic_guid]
        else:
            done_global[mindmap_topic.guid] = [topic_guid]

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons, done=None, done_global=None, level=0):
        """
        Create or update a MindManager topic from a MindmapTopic instance recursively.

        Args:
            topic: The current MindManager topic to update.
            mindmap_topic (MindmapTopic): The source MindmapTopic data.
            map_icons (list[MindmapIcon]): List of map icons to use.
            done (dict, optional): Dictionary tracking processed topics at current level.
            done_global (dict, optional): Global dictionary for tracking duplicate processing.
            level (int): Current hierarchical level.
            
        Returns:
            MindmapTopic: The processed MindmapTopic.
        """
        if done is None:
            done = {}
        if done_global is None:
            done_global = {}
        try:
            if self.turbo_mode:
                topic_guid = self.mindm.get_guid_from_topic(topic)
                self.update_done(topic_guid, mindmap_topic, level, done, done_global)
                for subtopic in mindmap_topic.subtopics:
                    try:
                        sub = self.mindm.add_subtopic_to_topic(topic, subtopic.text)
                        self.set_topic_from_mindmap_topic(sub, subtopic, map_icons, done, done_global, level + 1)
                    except Exception as e:
                        print(f"Error(1) processing topic/subtopic {mindmap_topic.guid}/{subtopic.guid}: {e}")
            else:
                topic, topic_guid = self.mindm.set_topic_from_mindmap_topic(topic, mindmap_topic, map_icons)
                self.update_done(topic_guid, mindmap_topic, level, done, done_global)

                if mindmap_topic.subtopics and len(mindmap_topic.subtopics) > 0:
                    # Sort subtopics alphabetically by text
                    mindmap_topic.subtopics.sort(key=lambda sub: sub.text)

                for subtopic in mindmap_topic.subtopics:
                    try:
                        if subtopic.guid in done:
                            this_guid_as_parent_exists = self.check_parent_exists(topic_guid, subtopic.guid)
                            if not this_guid_as_parent_exists:
                                cloned_subtopic = self.clone_mindmap_topic(subtopic)
                                sub = self.mindm.add_subtopic_to_topic(topic, cloned_subtopic.text)
                                self.set_topic_from_mindmap_topic(sub, cloned_subtopic, map_icons, done, done_global, level + 1)
                        else:
                            sub = self.mindm.add_subtopic_to_topic(topic, subtopic.text)
                            self.set_topic_from_mindmap_topic(sub, subtopic, map_icons, done, done_global, level + 1)
                    except Exception as e:
                        print(f"Error(2) processing topic/subtopic {mindmap_topic.guid}/{subtopic.guid}: {e}")
            return mindmap_topic
        except Exception as e:
            print(f"Error in set_topic_from_mindmap_topic at level {level} with topic {mindmap_topic.guid}: {e}")

    def check_parent_exists(self, topic_guid, this_guid, visited=None):
        """
        Recursively check if a parent-child relationship exists between topics.

        Args:
            topic_guid (str): The GUID of the topic to check.
            this_guid (str): The GUID that might be a parent of the topic.
            visited (set, optional): Set of visited GUIDs to avoid infinite recursion.

        Returns:
            bool: True if the parent-child relationship exists, False otherwise.
        """
        if visited is None:
            visited = set()
        if topic_guid in visited:
            return False
        visited.add(topic_guid)
        
        check = False
        if topic_guid in self.parents:
            parent_guid = self.parents[topic_guid]
            if parent_guid == this_guid:
                check = True
            else:
                check = self.check_parent_exists(parent_guid, this_guid, visited)
        return check

    def create_mindmap(self, verbose=False):
        """
        Create a MindManager mindmap document from the internal MindmapTopic structure.
        This includes counting occurrences, extracting tags/icons, and setting up relationships and links.

        Args:
            verbose (bool): (Optional) Enable verbose output.
        """
        tags = []
        map_icons = []
        relationships = []
        links = []

        self.parents = {}
        self.guid_counts = {}
        self.count_parent_and_child_occurrences(self.mindmap, self.guid_counts)
        self.get_parents_from_mindmap(self.mindmap, self.parents)

        self.get_tags_from_mindmap(self.mindmap, tags)
        self.get_map_icons_and_fix_refs_from_mindmap(self.mindmap, map_icons)
        self.get_relationships_from_mindmap(self.mindmap, relationships)
        self.get_topic_links_from_mindmap(self.mindmap, links)

        self.mindm.add_document(0)
        self.mindm.create_map_icons(map_icons)
        self.mindm.create_tags(tags, DUPLICATED_TAG)
        self.mindm.set_text_to_topic(self.mindm.get_central_topic(), self.mindmap.text)

        topic = self.mindm.get_central_topic()

        done_global = {}
        self.set_topic_from_mindmap_topic(topic=topic, mindmap_topic=self.mindmap, map_icons=map_icons, done={}, done_global=done_global)

        # Create relationships between topics
        for reference in relationships:
            object1_guids = done_global[reference.guid_1]
            object2_guids = done_global[reference.guid_2]
            for object1_guid in object1_guids:
                for object2_guid in object2_guids:
                    self.mindm.add_relationship(object1_guid, object2_guid, reference.label)

        # Create topic links
        for link in links:
            object1_guids = done_global[link.guid_1]
            object2_guids = done_global[link.guid_2]
            for object1_guid in object1_guids:
                for object2_guid in object2_guids:
                    self.mindm.add_topic_link(object1_guid, object2_guid, link.label)

    def create_mindmap_and_finalize(self):
        """
        Create the mindmap document and finalize it.
        """
        self.create_mindmap()
        self.finalize()

    def finalize(self):
        """
        Finalize the mindmap document by ensuring the maximum topic level is set, then calling MindManager's finalize.
        """
        if self.max_topic_level == 0:
            self.max_topic_level = self.get_max_topic_level(self.mindmap)
        self.mindm.finalize(self.max_topic_level)
    
    def set_background_image(self, image_path):
        """
        Set the background image for the MindManager document.

        Args:
            image_path (str): The file path to the background image.
        """
        self.mindm.set_document_background_image(image_path)
    
    def get_library_folder(self):
        """
        Get the library folder used by MindManager.

        Returns:
            The path to the library folder.
        """
        return self.mindm.get_library_folder()
    
    def get_grounding_information(self):
        """
        Extract grounding information from the mindmap, including the central topic and selected subtopics.

        Returns:
            tuple: (top_most_topic, subtopics) where top_most_topic is the central topic or a concatenated string
                   of non-selected topics, and subtopics is a comma-separated string of selected subtopics.
        """
        central_topic_text = self.mindmap.text
        subtopics = ""
        if len(self.selected_topic_texts) == 0: 
            top_most_topic = central_topic_text
        else:
            if self.central_topic_selected:
                top_most_topic = central_topic_text
                subtopics =  ",".join(self.selected_topic_texts)
            else:
                min_level = min(self.selected_topic_levels)
                max_level = max(self.selected_topic_levels)
                if (min_level == max_level):
                    top_most_topic = central_topic_text
                    subtopics =  ",".join(self.selected_topic_texts)
                else:
                    top_most_topic = ""
                    for i in range(len(self.selected_topic_levels)):
                        if self.selected_topic_levels[i] != max_level:
                            top_most_topic += self.selected_topic_texts[i] + "/"
                        else:
                            subtopics += self.selected_topic_texts[i] + ","

                    if top_most_topic.endswith("/"):
                        top_most_topic = top_most_topic[:-1]
                    if subtopics.endswith(","):
                        subtopics = subtopics[:-1]        
        return top_most_topic, subtopics



================================================
File: mindmap/serialization.py
================================================
from mindmap.mindmap import *
from mindmap import helpers

import json
import re
import uuid
import html2text

IGNORE_RTF = True

def serialize_object(obj, guid_mapping, name='', visited=None, ignore_rtf=True):
    """Serialize an object recursively, handling special fields and mapping GUIDs to IDs.
    
    Args:
        obj: The object to serialize
        guid_mapping: Dictionary mapping GUIDs to numeric IDs
        name (str, optional): The name of the attribute being serialized. Defaults to ''.
        visited (set, optional): Set of object IDs that have been visited to prevent cycles. Defaults to None.
        ignore_rtf (bool, optional): Whether to ignore RTF content. Defaults to True.
        
    Returns:
        object: Serialized representation of the input object to be exported at JSON
    """
    if visited is None:
        visited = set()
    if name == 'topic':
        if id(obj) in visited:
            return None
        visited.add(id(obj))
    visited.add(id(obj))
    if isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    if isinstance(obj, list):
        attr_name = 'topic' if name == 'subtopics' else ''
        return [serialize_object(item, guid_mapping, attr_name, visited) for item in obj]
    if isinstance(obj, dict):
        return {str(k): serialize_object(v, guid_mapping, visited=visited) for k, v in obj.items()}
    if hasattr(obj, '__dict__'):
        serialized = {}
        for attr_name, attr_value in vars(obj).items():
            if attr_name in ["parent", "level", "selected"]: 
                continue
            if attr_name in ["rtf"]:
                if ignore_rtf == True:
                    continue
            if attr_value is None or attr_value == "" or attr_value == []:
                continue
            new_attr_name = attr_name
            if new_attr_name in ["guid", "guid_1", "guid_2"]:
                if new_attr_name == "guid":
                    new_attr_name = "id"
                elif new_attr_name == "guid_1":
                    new_attr_name = "id_1"
                elif new_attr_name == "guid_2":
                    new_attr_name = "id_2"
                serialized[new_attr_name] = guid_mapping[attr_value]
            else:
                dict_val = serialize_object(attr_value, guid_mapping, attr_name, visited)
                if dict_val != {}:
                    serialized[new_attr_name] = dict_val
        return serialized
    return str(obj)

def serialize_object_simple(obj, name='', visited=None, ignore_rtf=True):
    """Serialize an object recursively without GUID mapping.
    
    Args:
        obj: The object to serialize
        name (str, optional): The name of the attribute being serialized. Defaults to ''.
        visited (set, optional): Set of object IDs that have been visited to prevent cycles. Defaults to None.
        ignore_rtf (bool, optional): Whether to ignore RTF content. Defaults to True.
        
    Returns:
        object: Simplified serialized representation of the input object to be exported at JSON
    """
    if visited is None:
        visited = set()
    if name == 'topic':
        if id(obj) in visited:
            return None
        visited.add(id(obj))
    if isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    if isinstance(obj, list):
        attr_name = 'topic' if name == 'subtopics' else ''
        return [serialize_object_simple(item, attr_name, visited) for item in obj]
    if isinstance(obj, dict):
        return {str(k): serialize_object_simple(v, k, visited) for k, v in obj.items()}
    if hasattr(obj, '__dict__'):
        serialized = {}
        for attr_name, attr_value in vars(obj).items():
            if attr_name in ["parent", "level", "selected"]:
                continue
            if attr_name in ["rtf"]:
                if ignore_rtf == True:
                    continue
            if attr_value is None or attr_value == "" or attr_value == []:
                continue
            dict_val = serialize_object_simple(attr_value, attr_name, visited)
            if dict_val != {}:
                serialized[attr_name] = dict_val
        return serialized
    return str(obj)

def serialize_mindmap(root_topic, guid_mapping, id_only=False):
    """Serialize a mindmap to valid Mermaid format including id and all other attributes (optional).
    
    Args:
        root_topic (MindmapTopic): Root topic of the mindmap
        guid_mapping (dict): Dictionary mapping GUIDs to numeric IDs
        id_only (bool, optional): If True, only include IDs without detailed attributes. Defaults to False.
        
    Returns:
        str: Mermaid formatted string representing the mindmap
    """
    lines = ["mindmap"]

    def serialize_topic_attributes(topic, guid_mapping, ignore_rtf=True):
        """Extract and serialize the attributes of a MindmapTopic.
        
        Args:
            topic (MindmapTopic): The topic to serialize
            guid_mapping (dict): Dictionary mapping GUIDs to numeric IDs
            
        Returns:
            dict: Dictionary containing serialized topic attributes
        """
        d = {}
        d["id"] = guid_mapping.get(topic.guid, topic.guid)
        #d["text"] = topic.text
        if topic.rtf != topic.text and not ignore_rtf == True:
            d["rtf"] = topic.rtf
        if topic.selected == True:
            d["selected"] = topic.selected
        if topic.links:
            d["links"] = []
            for link in topic.links:
                l = {}
                if link.text:
                    l["text"] = link.text
                if link.url:
                    l["url"] = link.url
                if link.guid:
                    l["id"] = guid_mapping.get(link.guid, link.guid)
                d["links"].append(l)
        if topic.image:
            d["image"] = {"text": topic.image.text}
        if topic.icons:
            d["icons"] = []
            for icon in topic.icons:
                i = {}
                if icon.text:
                    i["text"] = icon.text
                if icon.is_stock_icon is not None:
                    i["is_stock_icon"] = icon.is_stock_icon
                if icon.index is not None:
                    i["index"] = icon.index
                if icon.signature:
                    i["signature"] = icon.signature
                if icon.path:
                    i["path"] = icon.path
                if icon.group:
                    i["group"] = icon.group
                d["icons"].append(i)
        if topic.notes and (topic.notes.text or topic.notes.xhtml or topic.notes.rtf):
            notes = {}
            if topic.notes.text:
                notes["text"] = topic.notes.text
            if topic.notes.xhtml:
                notes["xhtml"] = topic.notes.xhtml
            if topic.notes.rtf:
                notes["rtf"] = topic.notes.rtf
            if notes != {}:
                d["notes"] = notes
        if topic.tags:
            d["tags"] = [tag.text for tag in topic.tags]
        if topic.references:
            d["references"] = []
            for ref in topic.references:
                r = {}
                if ref.guid_1:
                    r["id_1"] = guid_mapping.get(ref.guid_1, ref.guid_1)
                if ref.guid_2:
                    r["id_2"] = guid_mapping.get(ref.guid_2, ref.guid_2)
                if ref.direction:
                    r["direction"] = ref.direction
                if ref.label:
                    r["label"] = ref.label
                d["references"].append(r)
        d = helpers.replace_unicode_in_obj(d)
        return d
    
    def traverse(topic, indent):
        indent_str = "  " * indent
        node_text = helpers.escape_mermaid_text(topic.text)
        if id_only:
            id = guid_mapping.get(topic.guid, topic.guid)
            line = f"{indent_str}id{id}[{node_text}]"
            #line = f"{indent_str}({node_text})"
            #topic_attrs = {"id": id}
        else:
            line = f"{indent_str}[{node_text}]"
            topic_attrs = serialize_topic_attributes(topic, guid_mapping, ignore_rtf=IGNORE_RTF)
            json_comment = json.dumps(topic_attrs, ensure_ascii=True)
            line += f" %% {json_comment}"
        lines.append(line)
        for sub in topic.subtopics:
            traverse(sub, indent + 1)

    traverse(root_topic, 1)
    return "\n".join(lines)


def serialize_mindmap_markdown(root_topic, include_notes=True):
    """Serialize a mindmap to markdown including notes (optional).
    
    Args:
        root_topic (MindmapTopic): Root topic of the mindmap
        include_notes (bool, optional): If True, notes are included
        
    Returns:
        str: Markdown formatted string representing the mindmap
    """

    lines = []
    
    def traverse(topic, lines, level, prefix, index):
        text = topic.text
        notes_text = ""
        notes_xhtml = ""
        notes_rtf = ""

        if level > 0:
            if prefix == '':
                prefix = str(index)
            else:
                prefix = f"{prefix}.{index}"
        
        if topic.notes:
            if topic.notes.text or topic.notes.xhtml or topic.notes.rtf:
                if topic.notes.text:
                    notes_text = topic.notes.text
                if topic.notes.xhtml:
                    xhtml = topic.notes.xhtml
                    root_match = re.search(r'<(?:root|body)[^>]*>(.*?)</(?:root|body)>', xhtml, re.DOTALL | re.IGNORECASE)
                    if root_match:
                        xhtml = root_match.group(1)
                    xhtml = re.sub(r'<\?xml[^>]*\?>', '', xhtml)
                    xhtml = re.sub(r'<!DOCTYPE[^>]*>', '', xhtml)
                    try:
                        h = html2text.HTML2Text()
                        h.ignore_links = False
                        h.ignore_images = False
                        h.body_width = 0  # Don't wrap lines
                        notes_xhtml = h.handle(xhtml).strip()
                    except ImportError:
                        notes_xhtml = re.sub(r'<[^>]*>', '', xhtml).strip()
                if topic.notes.rtf:
                    # not implemented due to bad results
                    pass

        if include_notes and (notes_text or notes_xhtml or notes_rtf):
            notes_content = notes_text
            if notes_rtf:
                notes_content = notes_rtf
            if notes_xhtml:
                notes_content = notes_xhtml
            notes = f"Notes: {notes_content}  "
        else:
            notes = ""
        
        if topic.subtopics:
            line = f"{(level + 1) * '#'} {prefix if level > 0 else ''} {text}  "
            lines.append(line)
            if notes:
                lines.append(notes)

            sub_index = 0
            for sub in topic.subtopics:
                sub_index += 1
                traverse(sub, lines, level + 1, prefix, sub_index)
        else:
            line = f"- {text}  "
            lines.append(line)
            if notes:
                lines.append(notes)

    traverse(root_topic, lines, 0, '', 0)
    return "\n".join(lines)


def deserialize_mermaid_with_id(mermaid_text: str, guid_mapping: dict) -> MindmapTopic:
    """Convert Mermaid text with id to a Mindmap structure.
    
    Args:
        mermaid_text (str): Mermaid formatted string to parse
        guid_mapping (dict): Dictionary mapping numeric IDs to GUIDs
        
    Returns:
        MindmapTopic: Root topic of the deserialized mindmap
    """
    id_to_guid = {id_num: guid for guid, id_num in guid_mapping.items()}
    lines = [line for line in mermaid_text.splitlines() if line.strip()]
    if lines and lines[0].strip().lower() == "mindmap":
        lines = lines[1:]
    node_pattern = re.compile(r"^(id(\d+))\[(.*)\]$")
    root = None
    stack = []
    for line in lines:
        indent = len(line) - len(line.lstrip(" "))
        level = indent // 2
        stripped = line.lstrip(" ")
        match = node_pattern.match(stripped)
        if not match:
            continue        
        node_id_str = match.group(1)
        id_number = int(match.group(2))
        node_text = match.group(3)        
        if id_number in id_to_guid:
            guid = id_to_guid[id_number]
        else:
            guid = str(uuid.uuid4())
            id_to_guid[id_number] = guid
        node = MindmapTopic(guid=guid, text=node_text, level=level)
        if root is None:
            root = node
            stack.append((level, node))
            continue
        while stack and stack[-1][0] >= level:
            stack.pop()
        if stack:
            parent = stack[-1][1]
            node.parent = parent
            parent.subtopics.append(node)
        else:
            root.subtopics.append(node)
            node.parent = root
        stack.append((level, node))
    return root

def deserialize_mermaid_full(mermaid_text: str, guid_mapping: dict) -> MindmapTopic:
    """Convert Mermaid text with metadata to a Mindmap structure.
    
    Args:
        mermaid_text (str): Mermaid formatted string with JSON metadata to parse
        guid_mapping (dict): Dictionary mapping numeric IDs to GUIDs
        
    Returns:
        MindmapTopic: Root topic of the fully deserialized mindmap with all attributes
    """
    id_to_guid = {v: k for k, v in guid_mapping.items()}
    lines = [line for line in mermaid_text.splitlines() if line.strip()]
    if lines and lines[0].strip().lower() == "mindmap":
        lines = lines[1:]
    pattern = re.compile(r"^( *)(\[.*?\])\s*%%\s*(\{.*\})\s*$")
    root = None
    stack = []
    
    def restore_guid(numeric_id):
        try:
            num = int(numeric_id)
        except:
            return str(uuid.uuid4())
        if num in id_to_guid:
            return id_to_guid[num]
        else:
            new_guid = str(uuid.uuid4())
            id_to_guid[num] = new_guid
            return new_guid

    def process_subobject(field_dict: dict, id_field: str) -> dict:
        if id_field in field_dict:
            field_dict[id_field] = restore_guid(field_dict[id_field])
        return field_dict

    for line in lines:
        m = pattern.match(line)
        if not m:
            continue
        indent_str, bracket_part, json_part = m.groups()
        level = len(indent_str) // 2
        fallback_text = bracket_part.strip()[1:-1]
        try:
            attrs = json.loads(json_part)
        except Exception as e:
            attrs = {}
        if "id" in attrs:
            node_guid = restore_guid(attrs["id"])
        else:
            node_guid = str(uuid.uuid4())
        node_text = attrs.get("text", fallback_text)
        node_rtf = attrs.get("rtf", "")
        selected = attrs.get("selected", False)
        links = []
        if "links" in attrs and isinstance(attrs["links"], list):
            for link_dict in attrs["links"]:
                ld = dict(link_dict)
                ld = process_subobject(ld, "id")
                link_text = ld.get("text", "")
                link_url = ld.get("url", "")
                link_guid = ld.get("id", "")
                links.append(MindmapLink(text=link_text, url=link_url, guid=link_guid))
        image_obj = None
        if "image" in attrs and isinstance(attrs["image"], dict):
            image_obj = MindmapImage(text=attrs["image"].get("text", ""))
        icons = []
        if "icons" in attrs and isinstance(attrs["icons"], list):
            for icon_dict in attrs["icons"]:
                idict = dict(icon_dict)
                icons.append(MindmapIcon(
                    text=idict.get("text", ""),
                    is_stock_icon=idict.get("is_stock_icon", True),
                    index=idict.get("index", 1),
                    signature=idict.get("signature", ""),
                    path=idict.get("path", ""),
                    group=idict.get("group", "")
                ))
        notes_obj = None
        if "notes" in attrs:
            if isinstance(attrs["notes"], dict):
                notes_obj = MindmapNotes(
                    text=attrs["notes"].get("text", ""),
                    xhtml=attrs["notes"].get("xhtml", ""),
                    rtf=attrs["notes"].get("rtf", "")
                )
            elif isinstance(attrs["notes"], str):
                notes_obj = MindmapNotes(text=attrs["notes"])
        tags = []
        if "tags" in attrs and isinstance(attrs["tags"], list):
            for tag_item in attrs["tags"]:
                if isinstance(tag_item, dict):
                    tag_text = tag_item.get("text", "")
                else:
                    tag_text = str(tag_item)
                tags.append(MindmapTag(text=tag_text))
        references = []
        if "references" in attrs and isinstance(attrs["references"], list):
            for ref_dict in attrs["references"]:
                rd = dict(ref_dict)
                rd = process_subobject(rd, "id_1")
                rd = process_subobject(rd, "id_2")
                direction = rd.get("direction", None)
                label = rd.get("label", "")
                references.append(MindmapReference(
                    guid_1=rd.get("id_1", ""),
                    guid_2=rd.get("id_2", ""),
                    direction=direction,
                    label=label
                ))
        node = MindmapTopic(guid=node_guid, text=node_text, rtf=node_rtf, level=level, selected=selected)
        node.links = links
        node.image = image_obj
        node.icons = icons
        node.notes = notes_obj
        node.tags = tags
        node.references = references
        while stack and stack[-1][0] >= level:
            stack.pop()
        if stack:
            parent = stack[-1][1]
            node.parent = parent
            parent.subtopics.append(node)
        else:
            root = node
        stack.append((level, node))
    return root

def build_mapping(topic, guid_mapping):
    """Build a mapping of GUIDs to numeric IDs for an entire mindmap.
    
    Args:
        topic (MindmapTopic): Root topic of the mindmap
        guid_mapping (dict): Dictionary to store GUID to ID mappings
        
    Returns:
        None: The mapping is updated in-place
    """
    if topic.guid not in guid_mapping:
        guid_mapping[topic.guid] = len(guid_mapping) + 1
    for sub in topic.subtopics:
        build_mapping(sub, guid_mapping)


