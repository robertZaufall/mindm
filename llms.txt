Directory structure:
└── mindm/
    ├── README.md
    ├── LICENSE
    ├── pyproject.toml
    ├── update_version.py
    ├── mindm/
    │   ├── __init__.py
    │   ├── mindmanager.py
    │   ├── mindmanager_mac.py
    │   ├── mindmanager_mac_as.py
    │   ├── mindmanager_win.py
    │   └── as/
    │       ├── read.applescript
    │       ├── read.scpt
    │       ├── write.applescript
    │       └── write.scpt
    └── mindmap/
        ├── __init__.py
        ├── export.py
        ├── helpers.py
        ├── import.py
        ├── mindmap.py
        └── serialization.py

================================================
File: README.md
================================================
# mindm

Python library for interacting with locally installed MindManager™ on Windows and macOS platforms.

[![PyPI version](https://img.shields.io/pypi/v/mindm.svg)](https://pypi.org/project/mindm/)
[![Documentation](https://img.shields.io/badge/docs-latest-blue.svg)](https://robertzaufall.github.io/mindm/)

## Features

- Direct automation hooks for MindManager via platform-specific connectors in `mindm/`
- High-level document model, serialization helpers, and exporters in `mindmap/`
- YAML, JSON, and Mermaid serialization/deserialization helpers for round-tripping maps
- Sphinx documentation plus runnable snippets under `examples/`

## Project Layout

```
mindm/
├── mindm/        # Platform connectors (MindManager COM, AppleScript, etc.)
├── mindmap/      # MindmapDocument model + serialization helpers
├── docs/         # Sphinx documentation (make docs → docs/_build/html)
├── examples/     # Usage snippets / sanity scripts
├── dist/         # Build artifacts generated by python -m build
└── Makefile      # Build/packaging helpers (make help for summary)
```

## Installation

### PyPI

```bash
pip install mindm
```

### Local development

```bash
git clone https://github.com/robertZaufall/mindm
cd mindm
pip install -e ".[dev]"
```

## Getting Started

### Low-level example

Example for iterating over all topics in a mindmap and changing the topic text to uppercase:  
  
```python
import mindm.mindmanager

def iterate_topics(topic):
    text = m.get_text_from_topic(topic)
    m.set_text_to_topic(topic, text.upper())

    subtopics = m.get_subtopics_from_topic(topic)
    for subtopic in subtopics:
        iterate_topics(subtopic)

m = mindm.mindmanager.Mindmanager()
central_topic = m.get_central_topic()
iterate_topics(central_topic)
```

### High-level examples
  
Example for loading a mindmap from an open mindmap document and cloning it to a new document:  
  
```python
import mindmap.mindmap as mm

document = mm.MindmapDocument()
document.get_mindmap()
document.create_mindmap()
```
  
Example for serializing a mindmap to YAML format:  
  
```python
import yaml
import mindmap.mindmap as mm
import mindmap.serialization as mms

document = mm.MindmapDocument()
document.get_mindmap()

guid_mapping = {}
mms.build_mapping(document.mindmap, guid_mapping)

yaml_data = mms.serialize_object(document.mindmap, guid_mapping)
print(yaml.dump(yaml_data, sort_keys=False))
```
  
Example for serializing / deserializing a mindmap to / from Mermaid format including all attributes:  
  
```python
import json
import mindmap.mindmap as mm
import mindmap.serialization as mms

document = mm.MindmapDocument()
document.get_mindmap()

guid_mapping = {}
mms.build_mapping(document.mindmap, guid_mapping)

serialized = mms.serialize_mindmap(document.mindmap, guid_mapping, id_only=False)
print(serialized)

deserialized = mms.deserialize_mermaid_full(serialized, guid_mapping)
print(json.dumps(mms.serialize_object_simple(deserialized), indent=1))

document_new = mm.MindmapDocument()
document_new.mindmap = deserialized
document_new.create_mindmap()
```

Example for serializing / deserializing a simplified Mermaid mindmap (text and indentation only):  
  
```python
import mindmap.mindmap as mm
import mindmap.serialization as mms

document = mm.MindmapDocument()
document.get_mindmap()

simple_mermaid = mms.serialize_mindmap_simple(document.mindmap)
print(simple_mermaid)

simple_root = mms.deserialize_mermaid_simple(simple_mermaid)
```

Example for deserializing a simplified Mermaid mindmap (text and indentation only):  
  
```python
import mindmap.serialization as mms

mermaid = """
mindmap
  Creating an AI startup
    Vision & Strategy
      Mission and Value
        Problem statement
        Value proposition
        Long term goals
"""

mindmap_root = mms.deserialize_mermaid_simple(mermaid)
```

## Platform Specific Functionality

| Platform | Supported                                                                 | Not Supported                                  |
| -------- | ------------------------------------------------------------------------- | ---------------------------------------------- |
| Windows  | topics, subtopics, notes, icons, images, tags, external/topic links, relationships, RTF | floating topics, callouts, colors, lines, boundaries |
| macOS    | topics, subtopics, notes, relationships                                   | icons, images, tags, links, RTF, floating topics, callouts, colors, lines, boundaries |

## Development Workflow

- `pip install -e ".[dev]"` to get linting, testing, and docs dependencies
- `make build` (or `python -m build`) to create wheels and sdists in `dist/`
- `make docs` to rebuild the HTML documentation under `docs/_build/html`
- `pytest` for unit/integration coverage (add tests in `tests/` or `examples/`)
- `python examples/test.py` for a live smoke run against a connected MindManager instance

See `make help` for additional automation such as version bumps (`make update-version`) or GitHub releases.

## Documentation

Generated docs publish to GitHub Pages: [https://robertzaufall.github.io/mindm/](https://robertzaufall.github.io/mindm/).  
Run `make docs` locally to validate new API additions before contributing changes.



================================================
File: LICENSE
================================================
MIT License

Copyright (c) [2025] [Robert Zaufall]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "mindm"
version = "0.0.5.1"
authors = [
  { name="Robert Zaufall" },
]
description = "Python library for interacting with local installed MindManager(tm) on Windows and MacOS platform."
readme = "README.md"
requires-python = ">=3.9"
classifiers = [
    "Programming Language :: Python :: 3",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: MacOS :: MacOS X",
]

dependencies = [
  "pywin32; platform_system == 'Windows'",
  "appscript; sys_platform == 'darwin'",
  "regex",
  "html2text",
  "markdown"
]

[project.license]
text = "MIT"

[project.urls]
Homepage = "https://github.com/robertZaufall/mindm"
Issues = "https://github.com/robertZaufall/mindm/issues"

[project.optional-dependencies]
dev = [
  "pytest>=7.0",
  "black",
  "flake8",
  "gitingest",
]
docs = [
  "furo",
  "sphinx",
  "sphinx-pyproject",
  "sphinx.ext.autodoc",
  "sphinx.ext.napoleon",
  "sphinx.ext.autosummary",
  "gitingest",
]

[tool.setuptools.packages.find]
include = ["mindm", "mindmap"]
namespaces = false  # to disable scanning PEP 420 namespaces


================================================
File: update_version.py
================================================
#!/usr/bin/env python3
import re

# Read pyproject.toml
with open("pyproject.toml", "r") as f:
    content = f.read()

# Find version and update build number
version_pattern = r'version = "([\d]+)\.([\d]+)\.([\d]+)\.([\d]+)"'
version_match = re.search(version_pattern, content)

if version_match:
    major, minor, patch, build = version_match.groups()
    new_build = str(int(build) + 1)
    new_version = f"{major}.{minor}.{patch}.{new_build}"
    new_content = re.sub(version_pattern, f'version = "{new_version}"', content)
    
    # Write updated content back
    with open("pyproject.toml", "w") as f:
        f.write(new_content)
    
    print(f"Updated version to {new_version}")
else:
    print("Version pattern not found in pyproject.toml")


================================================
File: mindm/__init__.py
================================================
"""
mindm - Python library for interacting with local installed MindManager.

This package provides functionality to interact with MindManager on both
Windows and MacOS platforms. It allows reading, creating, and manipulating
mindmaps programmatically.

Main components:
- mindmap_helper: High-level interface for mindmap operations
- mindmanager: Platform-independent base class
- mindmanager_win: Windows-specific implementations
- mindmanager_mac: MacOS-specific implementations
"""

# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"


================================================
File: mindm/mindmanager.py
================================================
"""
Platform-independent interface for MindManager operations.

This module provides a unified interface for working with MindManager
across different platforms (Windows and MacOS) by delegating to the
appropriate platform-specific implementation.
"""

import sys

class Mindmanager():
    def __init__(self, charttype='auto', macos_access='appscript'):
        """
        Initialize a Mindmanager instance and delegate to the platform-specific implementation.

        Args:
            charttype (any): The type of chart to initialize with.
            macos_access (str): Method for accessing macOS features (default is 'appscript', alternative is 'applescript').
        """
        if sys.platform.startswith('win'):
            import mindm.mindmanager_win as mm
            self.platform = "win"
        elif sys.platform.startswith('darwin'):
            if macos_access == 'applescript':
                import mindm.mindmanager_mac_as as mm # AppleScript
            else:
                import mindm.mindmanager_mac as mm # Appscript
            self.platform = "darwin"

        self.mindm = mm.Mindmanager(charttype)

    def get_mindmanager_object(self) -> any:
        """
        Retrieve the MindManager application object.

        Returns:
            any: The MindManager application object.
        """
        return self.mindm.get_mindmanager_object()
    
    def get_active_document_object(self) -> any:
        """
        Retrieve the active document object.

        Returns:
            any: The active document object.
        """
        return self.mindm.get_active_document_object()
    
    def get_version(self) -> str:
        """
        Retrieve the version of the MindManager application.

        Returns:
            str: The version of the application.
        """
        return self.mindm.get_version()

    def get_library_folder(self) -> str:
        """
        Retrieve the library folder path for the MindManager application.

        Returns:
            str: The library folder path.
        """
        return self.mindm.get_library_folder()

    def set_document_background_image(self, path: str) -> None:
        """
        Set the background image for the document.

        Args:
            path (str): The path to the background image.

        Returns:
            None
        """
        return self.mindm.set_document_background_image(path)

    def document_exists(self) -> bool:
        """
        Check if a document exists in the current context.

        Returns:
            bool: True if the document exists, False otherwise.
        """
        return self.mindm.document_exists()

    def get_central_topic(self) -> any:
        """
        Retrieve the central topic of the mind map.

        Returns:
            any: The central topic.
        """
        return self.mindm.get_central_topic()

    def get_mindmaptopic_from_topic(self, topic) -> any:
        """
        Retrieve the topic properties of the topic.

        Returns:
            any: A mindmap topic
        """
        return self.mindm.get_mindmaptopic_from_topic(topic)

    def get_mindmaptopic_from_topic_content(self, topic) -> any:
        """
        Retrieve the topic properties of the topic including notes.

        Returns:
            any: A mindmap topic
        """
        return self.mindm.get_mindmaptopic_from_topic_content(topic)

    def get_mindmaptopic_from_topic_full(self, topic) -> any:
        """
        Retrieve the full set of topic properties of the topic.

        Returns:
            any: The mindmap topic.
        """
        return self.mindm.get_mindmaptopic_from_topic_full(topic)

    def get_topic_by_id(self, id: any) -> any:
        """
        Retrieve a topic by its identifier.

        Args:
            id (any): The identifier of the topic.

        Returns:
            any: The topic corresponding to the given id.
        """
        return self.mindm.get_topic_by_id(id)

    def get_selection(self) -> list:
        """
        Get the currently selected topics.

        Returns:
            list: A list of selected topics.
        """
        return self.mindm.get_selection()

    def get_level_from_topic(self, topic: any) -> any:
        """
        Get the level of the given topic within the mind map hierarchy.

        Args:
            topic (any): The topic to evaluate.

        Returns:
            any: The level of the topic.
        """
        return self.mindm.get_level_from_topic(topic)

    def get_text_from_topic(self, topic: any) -> str:
        """
        Retrieve the text content of a topic.

        Args:
            topic (any): The topic to extract text from.

        Returns:
            str: The text content of the topic.
        """
        return self.mindm.get_text_from_topic(topic)

    def get_title_from_topic(self, topic: any) -> str:
        """
        Retrieve the title of a topic.

        Args:
            topic (any): The topic to extract the title from.

        Returns:
            str: The title of the topic.
        """
        return self.mindm.get_title_from_topic(topic)

    def get_subtopics_from_topic(self, topic: any) -> list:
        """
        Retrieve all subtopics for the specified topic.

        Args:
            topic (any): The parent topic.

        Returns:
            list: A list of subtopics.
        """
        return self.mindm.get_subtopics_from_topic(topic)

    def get_links_from_topic(self, topic: any) -> list:
        """
        Retrieve all links associated with the specified topic.

        Args:
            topic (any): The topic to extract links from.

        Returns:
            list: A list of links.
        """
        return self.mindm.get_links_from_topic(topic)

    def get_image_from_topic(self, topic: any) -> any:
        """
        Retrieve the image associated with the topic.

        Args:
            topic (any): The topic to extract the image from.

        Returns:
            any: The image object or path.
        """
        return self.mindm.get_image_from_topic(topic)

    def get_icons_from_topic(self, topic: any) -> list:
        """
        Retrieve all icons associated with the topic.

        Args:
            topic (any): The topic to extract icons from.

        Returns:
            list: A list of icons.
        """
        return self.mindm.get_icons_from_topic(topic)

    def get_notes_from_topic(self, topic: any) -> any:
        """
        Retrieve the notes for the specified topic.

        Args:
            topic (any): The topic to extract notes from.

        Returns:
            any: The notes of the topic.
        """
        return self.mindm.get_notes_from_topic(topic)

    def get_tags_from_topic(self, topic: any) -> list:
        """
        Retrieve all tags attached to the topic.

        Args:
            topic (any): The topic to extract tags from.

        Returns:
            list: A list of tags.
        """
        return self.mindm.get_tags_from_topic(topic)

    def get_references_from_topic(self, topic: any) -> list:
        """
        Retrieve all references associated with the topic.

        Args:
            topic (any): The topic to extract references from.

        Returns:
            list: A list of references.
        """
        return self.mindm.get_references_from_topic(topic)

    def get_guid_from_topic(self, topic: any) -> str:
        """
        Retrieve the GUID (Globally Unique Identifier) of the topic.

        Args:
            topic (any): The topic to extract the GUID from.

        Returns:
            str: The GUID of the topic.
        """
        return self.mindm.get_guid_from_topic(topic)

    def add_subtopic_to_topic(self, topic: any, topic_text: str) -> any:
        """
        Add a subtopic with the provided text to an existing topic.

        Args:
            topic (any): The parent topic.
            topic_text (str): The text for the new subtopic.

        Returns:
            any: The newly created subtopic.
        """
        return self.mindm.add_subtopic_to_topic(topic, topic_text)

    def get_parent_from_topic(self, topic: any) -> any:
        """
        Retrieve the parent topic of the given topic.

        Args:
            topic (any): The topic to find the parent for.

        Returns:
            any: The parent topic.
        """
        return self.mindm.get_parent_from_topic(topic)

    def set_text_to_topic(self, topic: any, topic_text: str) -> None:
        """
        Set the text content for the specified topic.

        Args:
            topic (any): The topic to update.
            topic_text (str): The new text content.

        Returns:
            None
        """
        return self.mindm.set_text_to_topic(topic, topic_text)

    def set_title_to_topic(self, topic: any, topic_rtf: str) -> None:
        """
        Set the title (as RTF) for the specified topic.

        Args:
            topic (any): The topic to update.
            topic_rtf (str): The new title in RTF format.

        Returns:
            None
        """
        return self.mindm.set_title_to_topic(topic, topic_rtf)

    def add_tag_to_topic(self, topic: any, tag_text: str, topic_guid: str) -> None:
        """
        Add a tag to the specified topic.

        Args:
            topic (any): The topic to update.
            tag_text (str): The tag text to add.

        Returns:
            None
        """
        return self.mindm.add_tag_to_topic(topic, tag_text, topic_guid)

    def set_topic_from_mindmap_topic(self, topic: any, mindmap_topic: any, map_icons: any) -> any:
        """
        Update or create a topic based on the provided mindmap topic and icons.

        Args:
            topic (any): The current topic to update.
            mindmap_topic (any): The reference mindmap topic data.
            map_icons (any): Icons mapping for the topic.

        Returns:
            any: The updated topic.
        """
        return self.mindm.set_topic_from_mindmap_topic(topic, mindmap_topic, map_icons)

    def create_map_icons(self, map_icons: any) -> None:
        """
        Create map icons based on the provided mapping.

        Args:
            map_icons (any): The icons mapping.

        Returns:
            None
        """
        return self.mindm.create_map_icons(map_icons)

    def create_tags(self, tags: list[str], DUPLICATED_TAG: str) -> None:
        """
        Create tags for the mind map.

        Args:
            tags (list[str]): A list of tag names to create.
            DUPLICATED_TAG (str): The tag used in case of duplication.

        Returns:
            None
        """
        return self.mindm.create_tags(tags, DUPLICATED_TAG)

    def add_relationship(self, guid1: any, guid2: any, label: str = '') -> None:
        """
        Add a relationship between two topics.

        Args:
            guid1 (any): The GUID of the first topic.
            guid2 (any): The GUID of the second topic.
            label (str, optional): Optional label for the relationship. Defaults to ''.

        Returns:
            None
        """
        return self.mindm.add_relationship(guid1, guid2, label)

    def add_topic_link(self, guid1: any, guid2: any, label: str = '') -> None:
        """
        Create a link between two topics.

        Args:
            guid1 (any): The GUID of the source topic.
            guid2 (any): The GUID of the target topic.
            label (str, optional): Optional label for the link. Defaults to ''.

        Returns:
            None
        """
        return self.mindm.add_topic_link(guid1, guid2, label)

    def add_document(self, max_topic_level: int) -> None:
        """
        Add a new mind map document with a specified maximum topic level.

        Args:
            max_topic_level (int): The maximum depth of topics in the document.

        Returns:
            None
        """
        return self.mindm.add_document(max_topic_level)

    def finalize(self, max_topic_level: int) -> None:
        """
        Finalize and process the mind map document.

        Args:
            max_topic_level (int): The maximum depth of topics processed.

        Returns:
            None
        """
        return self.mindm.finalize(max_topic_level)


================================================
File: mindm/mindmanager_mac.py
================================================
"""
MacOS-specific implementation of the Mindmanager interface.

This module provides MacOS platform-specific implementation for interacting
with MindManager application, including functionality for manipulating topics,
properties, relationships, and document structure.
"""

import os
from appscript import *

from mindmap.mindmap import MindmapLink, MindmapImage, MindmapNotes, MindmapIcon, MindmapTag, MindmapReference, MindmapTopic

class Mindmanager:

    MACOS_MERGE_ALL_WINDOWS = False
    MACOS_LIBRARY_FOLDER = os.path.join(os.path.expanduser("~"), "Library", "Application Support", "Mindjet", "MindManager", "XX", "English", "Library")

    def __init__(self, charttype):
        self._mindmanager = app('MindManager')
        self._version = self._mindmanager.version.get().split('.')[0]
        self._master_window = self._mindmanager.windows[1].id.get()
        self._charttype = charttype
        self._library_folder = self.MACOS_LIBRARY_FOLDER.replace("XX", self._version)
        if self._version != '24':
            orgchart_template_path = os.path.join(self._library_folder, "Templates", "Blank Templates", "Org-Chart Map.mmat")
        else:
            orgchart_template_path = os.path.join(self._library_folder, "Templates", "Blank Templates", "Organization Chart.mmat")
        self._orgchart_template = mactypes.Alias(orgchart_template_path)
        self._radial_template = mactypes.Alias(os.path.join(self._library_folder, "Templates", "Blank Templates", "Radial Map.mmat"))

    def get_mindmanager_object(self):
        return self._mindmanager
        
    def get_active_document_object(self):
        if self.document_exists():
            return self._mindmanager.documents[1]
        return None
        
    def get_library_folder(self):
        return self._library_folder
    
    def get_version(self):
        return self._version

    def set_document_background_image(self, path):
        pass
    
    def document_exists(self):
        try:
            return self._mindmanager.documents[1].exists()
        except Exception as e:
            print(f"Error checking document existence: {e}")
            return False

    def get_central_topic(self) -> 'MindmapTopic':
        try:
            topic = self._mindmanager.documents[1].central_topic.get()
            #callouts = topic.callouts.get()
            #relationships = topic.relationships.get()
            #subtopics = topic.subtopics.get()
            #shape = topic.shape.get()
            #attributes = topic.attributes.get()
            #props = topic.properties.get()
            #task = topic.task.get()
            #task_properties = task.properties.get()
            mindmap_topic = MindmapTopic(
                guid=self.get_guid_from_topic(topic),
                text=self.get_text_from_topic(topic),
                rtf=self.get_title_from_topic(topic),
                level=self.get_level_from_topic(topic),
            )
            return mindmap_topic
        except Exception as e:
            print(f"Error getting central topic: {e}")
            return None
    
    def get_mindmaptopic_from_topic(self, topic) -> 'MindmapTopic':
        mindmap_topic = MindmapTopic(
            guid=self.get_guid_from_topic(topic),
            text=self.get_text_from_topic(topic),
            rtf=self.get_title_from_topic(topic),
            level=self.get_level_from_topic(topic),
        )
        return mindmap_topic
    
    def get_mindmaptopic_from_topic_content(self, topic) -> 'MindmapTopic':
        mindmap_topic = MindmapTopic(
            guid=self.get_guid_from_topic(topic),
            text=self.get_text_from_topic(topic),
            rtf=self.get_title_from_topic(topic),
            level=self.get_level_from_topic(topic),
            notes=self.get_notes_from_topic(topic),
        )
        return mindmap_topic
    
    def get_mindmaptopic_from_topic_full(self, topic) -> 'MindmapTopic':
        mindmap_topic = MindmapTopic(
            guid=self.get_guid_from_topic(topic),
            text=self.get_text_from_topic(topic),
            rtf=self.get_title_from_topic(topic),
            level=self.get_level_from_topic(topic),
            notes=self.get_notes_from_topic(topic),
            links=self.get_links_from_topic(topic),
            image=self.get_image_from_topic(topic),
            icons=self.get_icons_from_topic(topic),
            tags=self.get_tags_from_topic(topic),
            references=self.get_references_from_topic(topic),
        )
        return mindmap_topic
        
    def get_topic_by_id(self, id):
        try:
            found_topics = self._mindmanager.documents[1].topics[its.id == id]
            if found_topics.count() == 0:
                return None
            return found_topics[0].get()
        except Exception as e:
            print(f"Error getting topic by id: {e}")
            return None
    
    def get_selection(self):
        selection = []
        try:
            items = self._mindmanager.documents[1].selection.get()
            for item in items:
                type = item.class_.get()
                if type.name == 'topic':
                    selection.append(item)
        except Exception as e:
            print(f"Error getting selection: {e}")
        return selection
    
    def get_level_from_topic(self, topic):
        try:
            return topic.level.get()
        except Exception as e:
            print(f"Error getting level from topic: {e}")
            return None
    
    def get_text_from_topic(self, topic):
        try:
            text = topic.name.get()
            return text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        except Exception as e:
            print(f"Error getting text from topic: {e}")
            return ""
    
    def get_title_from_topic(self, topic):
        try:
            title = topic.title.get()
            return title
        except Exception as e:
            print(f"Error getting title from topic: {e}")
            return ""
    
    def get_subtopics_from_topic(self, topic):
        try:
            return topic.subtopics.get()
        except Exception as e:
            print(f"Error getting subtopics from topic: {e}")
            return []

    def get_links_from_topic(self, topic) -> list['MindmapLink']:
        return None
        # this results in a severe runtime error of MindManager
        link = topic.hyperlink_URL.get()
        # this has no effect
        label = topic.label.get()
        return MindmapLink(link=link, label=label) if label != '' else None

    def get_image_from_topic(self, topic) -> MindmapImage:
        return None

    def get_icons_from_topic(self, topic) -> list[MindmapIcon]:
        return []

    def get_notes_from_topic(self, topic) -> MindmapNotes:
        try:
            notes = topic.notes.get()
            return MindmapNotes(text=notes)
        except Exception as e:
            print(f"Error getting notes from topic: {e}")
            return None

    def get_tags_from_topic(self, topic) -> list[MindmapTag]:
        return []

    def get_references_from_topic(self, topic) -> list[MindmapReference]:
        references = []
        try:
            relationships = topic.relationships.get()
            for relationship in relationships:
                relationship_instance = relationship.get()
                starting_location = relationship_instance.starting_location.get()
                ending_location = relationship_instance.ending_location.get()
                if starting_location == topic:
                    references.append(MindmapReference(
                        direction=1,
                        guid_1=starting_location.id.get(),
                        guid_2=ending_location.id.get()
                    ))
        except Exception as e:
            print(f"Error in get_references_from_topic: {e}")
        return references

    def get_guid_from_topic(self, topic) -> str:
        try:
            return topic.id.get()
        except Exception as e:
            print(f"Error in get_guid_from_topic: {e}")
            return ""
        
    def add_subtopic_to_topic(self, topic, topic_text):
        try:
            topic_instance = topic.get()
            return topic_instance.subtopics.end.make(new=k.topic, with_properties={k.name: topic_text})
        except Exception as e:
            print(f"Error in add_subtopic_to_topic: {e}")
            return None

    def get_parent_from_topic(self, topic):
        try:
            return topic.parent.get()
        except Exception as e:
            print(f"Error in get_parent_from_topic: {e}")
            return None

    def set_text_to_topic(self, topic, topic_text):
        try:
            topic.name.set(topic_text)
        except Exception as e:
            print(f"Error in set_text_to_topic: {e}")

    def set_title_to_topic(self, topic, topic_rtf):
        try:
            topic.title.set(topic_rtf)
        except Exception as e:
            print(f"Error in set_title_to_topic: {e}")

    def add_tag_to_topic(self, topic, tag_text, topic_guid):
        pass

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons):
        try:
            topic_id = topic.id.get()
            self.set_text_to_topic(topic, mindmap_topic.text)
            refreshed_topic = self.get_topic_by_id(topic_id)
            if mindmap_topic.rtf != '':
                self.set_title_to_topic(refreshed_topic, mindmap_topic.rtf)
                refreshed_topic = self.get_topic_by_id(topic_id)
            if mindmap_topic.notes:
                refreshed_topic.notes.set(mindmap_topic.notes.text)
                refreshed_topic = self.get_topic_by_id(topic_id)
            return refreshed_topic, topic_id
        except Exception as e:
            print(f"Error in set_topic_from_mindmap_topic: {e}")
            return None, None

    def create_map_icons(self, map_icons):
        pass

    def create_tags(self, tags: list['str'], DUPLICATED_TAG: str):
        pass

    def add_relationship(self, guid1, guid2, label = ''):
        try:
            topic1 = self.get_topic_by_id(guid1)
            topic2 = self.get_topic_by_id(guid2)
            if topic1 is None or topic2 is None:
                print("Error in add_relationship: One or both topics not found.")
                return
            topic1.make(new=k.relationship, with_properties={k.starting_location: topic1, k.ending_location: topic2})
        except Exception as e:
            print(f"Error in add_relationship: {e}")

    def add_topic_link(self, guid1, guid2, label=''):
        pass

    def add_document(self, max_topic_level):
        cnt_subtopics = len(self._mindmanager.documents[1].central_topic.subtopics.get())
        if self._charttype == "orgchart":
            template_alias = self._orgchart_template
        if self._charttype == "radial":
            template_alias = self._radial_template
        if self._charttype == "auto":
            if max_topic_level > 2 and cnt_subtopics > 4:
                template_alias = self._orgchart_template
            else:
                template_alias = self._radial_template
        self._mindmanager.open(template_alias)

    def finalize(self, max_topic_level):
        self._mindmanager.documents[1].balance_map()
        self._mindmanager.activate()
        if self.MACOS_MERGE_ALL_WINDOWS:
            self.merge_windows()
        self._mindmanager = None
        del self._mindmanager



================================================
File: mindm/mindmanager_mac_as.py
================================================
"""
MacOS-specific implementation of the Mindmanager interface.
This class implementation uses the native AppleScript approach.

This module provides MacOS platform-specific implementation for interacting
with MindManager application, including functionality for manipulating topics,
properties, relationships, and document structure.
"""

import os
import sys
import json
import subprocess

from mindmap.mindmap import (
    MindmapLink,
    MindmapImage,
    MindmapNotes,
    MindmapIcon,
    MindmapTag,
    MindmapReference,
    MindmapTopic,
)
import mindmap.serialization as mms

APPLESCRIPT_READ = os.path.join(os.path.dirname(__file__), "as", "read.scpt")
APPLESCRIPT_WRITE = os.path.join(os.path.dirname(__file__), "as", "write.scpt")

def _run_applescript(script: str, args: list = None) -> str:
    if args is None:
        args = []
    
    command = ["osascript", "-e", script] + args
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"AppleScript error: {e.stderr}")
        return ""

def _run_compiled_applescript(script_path: str, args: list = None) -> str:
    if args is None:
        args = []
    
    command = ["osascript", script_path] + (args or [])
    
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print("osascript returned", e.returncode)
        print("--- stdout ---\n", e.stdout)
        print("--- stderr ---\n", e.stderr)
        return ""
    
class Mindmanager:

    MACOS_MERGE_ALL_WINDOWS = False
    MACOS_LIBRARY_FOLDER = os.path.join(
        os.path.expanduser("~"), 
        "Library", 
        "Application Support", 
        "Mindjet", 
        "MindManager", 
        "XX", 
        "English", 
        "Library"
    )

    def __init__(self, charttype):
        self._charttype = charttype

        # Get version from MindManager
        script = 'tell application "MindManager" to return version'
        version_str = _run_applescript(script)
        if version_str:
            self._version = version_str.split('.')[0]
        else:
            self._version = "0"

        self._library_folder = self.MACOS_LIBRARY_FOLDER.replace("XX", self._version)
        if self._version == '24':
            orgchart_template_path = os.path.join(self._library_folder, "Templates", "Blank Templates", "Organization Chart.mmat")
        else:
            orgchart_template_path = os.path.join(self._library_folder, "Templates", "Blank Templates", "Org-Chart Map.mmat")
        self._orgchart_template = orgchart_template_path
        self._radial_template = os.path.join(self._library_folder, "Templates", "Blank Templates", "Radial Map.mmat")

    def _read(self, modus, arguments = None) -> list['MindmapTopic']:
        if arguments:
             script_args = [modus] + arguments
        else:
            script_args = [modus]

        json_string = _run_compiled_applescript(APPLESCRIPT_READ, script_args)
    
        if not json_string:
            return None  # no data returned
        try:
            jsonObject = json.loads(json_string)
            if isinstance(jsonObject, dict):
                # It's a single tree structure
                topic = self._dict_to_mindmap_topic(jsonObject)
                return [topic] if topic else None
            elif isinstance(jsonObject, list):
                # It's a list of topic structures
                topics = []
                for item in jsonObject:
                    if isinstance(item, dict):
                        topic = self._dict_to_mindmap_topic(item)
                        if topic:
                            topics.append(topic)
                return topics
            else:
                # Unexpected format
                print(f"Unexpected JSON format received: {type(jsonObject)}")
                return None
        except json.JSONDecodeError as e:
            print(f"Error parsing JSON from AppleScript: {e}")
            return None
    
    def _write(self, modus, mindmap_topic):
        json_string = json.dumps(mms.serialize_object_simple(mindmap_topic))
        script_args = [modus] + [json_string]
        result = _run_compiled_applescript(APPLESCRIPT_WRITE, script_args)
        return result

    def _dict_to_mindmap_topic(self, node_dict: dict) -> 'MindmapTopic':
        """
        Helper to recursively convert a dict of the form:
        { "guid": ..., "text": ..., "level": ..., "notes": ..., "subtopics": [ ... ] }
        into a MindmapTopic object with subtopics.
        """
        notes_obj = None
        if node_dict.get("notes"):
            notes_obj = MindmapNotes(text=node_dict["notes"])
        topic = MindmapTopic(
            guid=node_dict.get("guid", ""),
            text=node_dict.get("text", ""),
            level=int(node_dict.get("level", 0)),
            notes=notes_obj,
        )
        subtopics = node_dict.get("subtopics", [])
        for child_dict in subtopics:
            child_topic = self._dict_to_mindmap_topic(child_dict)
            if child_topic:
                topic.subtopics.append(child_topic)
                child_topic.parent = topic

        return topic
    
    def get_mindmanager_object(self):
        return None

    def get_active_document_object(self):
        """
        Return 'document 1' if a document is open, else None.
        """
        return "document 1" if self.document_exists() else None

    def get_library_folder(self):
        return self._library_folder

    def get_version(self):
        return self._version

    def set_document_background_image(self, path):
        pass

    def document_exists(self):
        """
        Returns True if there's at least one open document in MindManager.
        """
        script = '''
            tell application "MindManager"
                if (count of documents) > 0 then
                    return "true"
                else
                    return "false"
                end if
            end tell
        '''
        result = _run_applescript(script)
        return (result == "true")

    def get_central_topic(self) -> 'MindmapTopic':
        """
        Return the central topic's ID or None if not found.
        """
        result = self._read("getTree")
        return result[0] if result else None

    def get_mindmaptopic_from_topic(self, topic_id) -> 'MindmapTopic':
        """
        Returns a MindmapTopic with guid, text, rtf and level,
        all retrieved via a single AppleScript call.
        """
        if not topic_id:
            return None

        # Single AppleScript to grab all basic properties at once:
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set theGUID to id of theTopic
                    set theName to name of theTopic
                    set theTitle to title of theTopic
                    set theLevel to level of theTopic
                    return theGUID & "%%" & theName & "%%" & theTitle & "%%" & (theLevel as text)
                on error
                    return ""
                end try
            end tell
        '''
        result = _run_applescript(script)
        if not result:
            return None  # topic not found or error

        parts = result.split("%%", 3)  # we expect exactly 4 parts
        if len(parts) < 4:
            return None

        theGUID, theName, theTitle, theLevelStr = parts

        # Convert level to integer if possible
        try:
            theLevel = int(theLevelStr)
        except ValueError:
            theLevel = None

        # Clean up the text property so it mimics your old replacements
        theName = theName.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")

        # Construct and return the MindmapTopic
        return MindmapTopic(
            guid=theGUID,
            text=theName,
            rtf=theTitle,
            level=theLevel,
        )

    def get_mindmaptopic_from_topic_content(self, topic_id) -> 'MindmapTopic':
        """
        Returns a MindmapTopic with guid, text, rtf, level, and notes,
        all retrieved via a single AppleScript call.
        """
        if not topic_id:
            return None

        # Single AppleScript to grab all basic properties at once:
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set theGUID to id of theTopic
                    set theName to name of theTopic
                    set theTitle to title of theTopic
                    set theLevel to level of theTopic
                    set theNotes to notes of theTopic
                    return theGUID & "%%" & theName & "%%" & theTitle & "%%" & (theLevel as text) & "%%" & theNotes
                on error
                    return ""
                end try
            end tell
        '''
        result = _run_applescript(script)
        if not result:
            return None  # topic not found or error

        parts = result.split("%%", 4)  # we expect exactly 5 parts
        if len(parts) < 5:
            return None

        theGUID, theName, theTitle, theLevelStr, theNotes = parts

        # Convert level to integer if possible
        try:
            theLevel = int(theLevelStr)
        except ValueError:
            theLevel = None

        # Clean up the text property so it mimics your old replacements
        theName = theName.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")

        # Build the MindmapNotes object if notes are non-empty
        notes_obj = MindmapNotes(text=theNotes) if theNotes else None

        # Construct and return the MindmapTopic
        return MindmapTopic(
            guid=theGUID,
            text=theName,
            rtf=theTitle,
            level=theLevel,
            notes=notes_obj,
        )

    def get_mindmaptopic_from_topic_full(self, topic_id) -> 'MindmapTopic':
        """
        Returns a MindmapTopic with guid, text, rtf, level, notes, and references,
        all via one AppleScript call. (links/icons/tags/image remain unimplemented.)
        """
        if not topic_id:
            return None

        # Single AppleScript to grab all properties + references
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set theGUID to id of theTopic
                    set theName to name of theTopic
                    set theTitle to title of theTopic
                    set theLevel to level of theTopic
                    set theNotes to notes of theTopic
                    set rels to relationships of theTopic
                    set referencesString to ""
                    repeat with r in rels
                        set sLoc to id of (starting location of r)
                        set eLoc to id of (ending location of r)
                        set referencesString to referencesString & sLoc & "||" & eLoc & "||--||"
                    end repeat
                    return theGUID & "%%" & theName & "%%" & theTitle & "%%" & (theLevel as text) & "%%" & theNotes & "%%" & referencesString
                on error
                    return ""
                end try
            end tell
        '''
        result = _run_applescript(script)
        if not result:
            return None

        # We expect 6 parts: guid, name, title, level, notes, referencesString
        parts = result.split("%%", 5)
        if len(parts) < 6:
            return None

        theGUID, theName, theTitle, theLevelStr, theNotes, referencesRaw = parts

        # Convert level to integer if possible
        try:
            theLevel = int(theLevelStr)
        except ValueError:
            theLevel = None

        # Clean up the text property
        theName = theName.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")

        # Build the MindmapNotes object if notes are non-empty
        notes_obj = MindmapNotes(text=theNotes) if theNotes else None

        # Parse references:
        # referencesRaw might look like "GUID1||GUID2||--||GUID3||GUID4||--||"
        references = []
        if referencesRaw:
            rel_chunks = referencesRaw.split("||--||")
            for chunk in rel_chunks:
                chunk = chunk.strip()
                if not chunk:
                    continue
                pair = chunk.split("||")
                if len(pair) == 2:
                    sLoc, eLoc = pair
                    if sLoc == theGUID:  # If it matches the old pattern
                        references.append(
                            MindmapReference(direction=1, guid_1=sLoc, guid_2=eLoc)
                        )
                    else:
                        # Or handle direction=2 or other logic if needed
                        pass

        # For now, links, icons, tags, image remain unimplemented => empty
        links = []
        icons = []
        tags = []
        image = None

        return MindmapTopic(
            guid=theGUID,
            text=theName,
            rtf=theTitle,
            level=theLevel,
            notes=notes_obj,
            links=links,
            image=image,
            icons=icons,
            tags=tags,
            references=references,
        )
    
    def get_topic_by_id(self, topic_id):
        return topic_id

    def get_selection(self):
        """
        Return a list of topic IDs in the current selection.
        """
        result = self._read("getSelection")
        return result

    def get_level_from_topic(self, topic_id):
        if not topic_id:
            return None
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    return level of theTopic
                on error
                    return ""
                end try
            end tell
        '''
        level_str = _run_applescript(script)
        return int(level_str) if level_str.isdigit() else None

    def get_text_from_topic(self, topic_id):
        if not topic_id:
            return ""
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    return name of theTopic
                on error
                    return ""
                end try
            end tell
        '''
        text = _run_applescript(script)
        # Replace certain characters (as in original code)
        text = text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        return text

    def get_title_from_topic(self, topic_id):
        if not topic_id:
            return ""
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    return title of theTopic
                on error
                    return ""
                end try
            end tell
        '''
        return _run_applescript(script)

    def get_subtopics_from_topic(self, topic_id):
        """
        Return a list of subtopic IDs.
        """
        if not topic_id:
            return []
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set subTs to subtopics of theTopic
                    set output to ""
                    repeat with t in subTs
                        set output to output & (id of t) & linefeed
                    end repeat
                    return output
                on error
                    return ""
                end try
            end tell
        '''
        raw = _run_applescript(script)
        return [x.strip() for x in raw.splitlines() if x.strip()]

    def get_links_from_topic(self, topic_id) -> list[MindmapLink]:
        return []

    def get_image_from_topic(self, topic_id) -> MindmapImage:
        return None

    def get_icons_from_topic(self, topic_id) -> list[MindmapIcon]:
        return []

    def get_notes_from_topic(self, topic_id) -> MindmapNotes:
        """
        Return MindmapNotes or None.
        """
        if not topic_id:
            return None
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    return notes of theTopic
                on error
                    return ""
                end try
            end tell
        '''
        notes_text = _run_applescript(script)
        if notes_text:
            return MindmapNotes(text=notes_text)
        return None

    def get_tags_from_topic(self, topic_id) -> list[MindmapTag]:
        return []

    def get_references_from_topic(self, topic_id) -> list[MindmapReference]:
        """
        Return a list of MindmapReference objects for the given topic.
        """
        references = []
        if not topic_id:
            return references

        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set rels to relationships of theTopic
                    if (count of rels) = 0 then
                        return ""
                    end if
                    set outList to ""
                    repeat with r in rels
                        set sLoc to id of (starting location of r)
                        set eLoc to id of (ending location of r)
                        set outList to outList & sLoc & "||" & eLoc & linefeed
                    end repeat
                    return outList
                on error
                    return ""
                end try
            end tell
        '''
        raw = _run_applescript(script)
        for line in raw.splitlines():
            parts = line.split("||")
            if len(parts) == 2:
                sLoc, eLoc = parts
                if sLoc == topic_id:
                    references.append(
                        MindmapReference(
                            direction=1,
                            guid_1=sLoc,
                            guid_2=eLoc
                        )
                    )
        return references

    def get_guid_from_topic(self, topic_id) -> str:
        return topic_id if topic_id else ""

    def add_subtopic_to_topic(self, topic_id, topic_text):
        """
        Create a new subtopic under `topic_id` with `topic_text`.
        Return the new subtopic's ID or None on failure.
        """
        if not topic_id:
            return None
        safe_text = topic_text.replace('"', '\\"')
        script = f'''
            tell application "MindManager"
                try
                    set parentTopic to first topic of document 1 whose id is "{topic_id}"
                    set newT to make new topic at end of subtopics of parentTopic with properties {{name:"{safe_text}"}}
                    return id of newT
                on error
                    return ""
                end try
            end tell
        '''
        new_id = _run_applescript(script)
        return new_id if new_id else None

    def get_parent_from_topic(self, topic_id):
        """
        Return the parent's ID or None if there is no parent or the topic doesn't exist.
        """
        if not topic_id:
            return None
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set p to parent of theTopic
                    if p is not missing value then
                        return id of p
                    else
                        return ""
                    end if
                on error
                    return ""
                end try
            end tell
        '''
        result = _run_applescript(script)
        return result if result else None

    def set_text_to_topic(self, topic_id, topic_text):
        """
        Set the topic's text (equivalent to topic.name.set).
        """
        if not topic_id:
            return
        safe_text = topic_text.replace('"', '\\"')
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set name of theTopic to "{safe_text}"
                end try
            end tell
        '''
        _run_applescript(script)

    def set_title_to_topic(self, topic_id, topic_rtf):
        """
        Set the topic's title (equivalent to topic.title.set).
        """
        if not topic_id:
            return
        safe_text = topic_rtf.replace('"', '\\"')
        script = f'''
            tell application "MindManager"
                try
                    set theTopic to first topic of document 1 whose id is "{topic_id}"
                    set title of theTopic to "{safe_text}"
                end try
            end tell
        '''
        _run_applescript(script)

    def add_tag_to_topic(self, topic_id, tag_text, topic_guid):
        pass

    def set_topic_from_mindmap_topic(self, topic_id, mindmap_topic, map_icons):
        """
        Updates the topic's text, RTF title, and notes from `mindmap_topic` 
        via a single AppleScript call. 
        Returns (refreshed_topic_id, original_topic_id).
        """
        if not topic_id and not mindmap_topic:
            return None, None
        
        if not topic_id:
            try:
                self._write("writeTree", mindmap_topic)
                return None, None

            except Exception as e:
                print(f"Error in set_topic_from_mindmap_topic: {e}")
                return None, None
        else:
            try:
                script_lines = []
                script_lines.append('tell application "MindManager"')
                script_lines.append('    try')
                script_lines.append(f'        set theTopic to first topic of document 1 whose id is "{topic_id}"')
                safe_text = (mindmap_topic.text or "").replace('"', '\\"')
                script_lines.append(f'        set name of theTopic to "{safe_text}"')
                if mindmap_topic.rtf:
                    safe_rtf = mindmap_topic.rtf.replace('"', '\\"')
                    script_lines.append(f'        set title of theTopic to "{safe_rtf}"')
                if mindmap_topic.notes:
                    safe_notes = (mindmap_topic.notes.text or "").replace('"', '\\"')
                    script_lines.append(f'        set notes of theTopic to "{safe_notes}"')
                script_lines.append('        return id of theTopic')
                script_lines.append('    on error errMsg')
                script_lines.append('        return ""')
                script_lines.append('    end try')
                script_lines.append('end tell')
                full_script = "\n".join(script_lines)
                refreshed_id = _run_applescript(full_script)
                if not refreshed_id:
                    return None, None
                return refreshed_id, topic_id

            except Exception as e:
                print(f"Error in set_topic_from_mindmap_topic: {e}")
                return None, None

    def create_map_icons(self, map_icons):
        pass

    def create_tags(self, tags: list[str], DUPLICATED_TAG: str):
        pass

    def add_relationship(self, guid1, guid2, label=''):
        if not guid1 or not guid2:
            print("Error in add_relationship: One or both topic IDs missing.")
            return
        script = f'''
            tell application "MindManager"
                try
                    set t1 to first topic of document 1 whose id is "{guid1}"
                    set t2 to first topic of document 1 whose id is "{guid2}"
                    if t1 is not missing value and t2 is not missing value then
                        make new relationship with properties {{starting location:t1, ending location:t2}}
                    end if
                on error errMsg
                    return ""
                end try
            end tell
        '''
        _run_applescript(script)

    def add_topic_link(self, guid1, guid2, label=''):
        pass

    def add_document(self, max_topic_level):
        """
        Opens the correct template based on charttype and subtopic counts.
        """
        if not self.document_exists():
            cnt_subtopics = 0
        else:
            script_count = '''
                tell application "MindManager"
                    set c to count of subtopics of central topic of document 1
                    return c
                end tell
            '''
            res = _run_applescript(script_count)
            try:
                cnt_subtopics = int(res)
            except:
                cnt_subtopics = 0

        if self._charttype == "orgchart":
            template_alias = self._orgchart_template
        elif self._charttype == "radial":
            template_alias = self._radial_template
        else:
            # "auto"
            if max_topic_level > 2 and cnt_subtopics > 4:
                template_alias = self._orgchart_template
            else:
                template_alias = self._radial_template

        safe_path = template_alias.replace('"', '\\"')
        script_open = f'''
            tell application "MindManager"
                open POSIX file "{safe_path}"
            end tell
        '''
        _run_applescript(script_open)

    def finalize(self, max_topic_level):
        """
        Balance the map, activate MindManager, optionally merge windows, and clean up.
        """
        if not self.document_exists():
            return

        # Balance map
        script_balance = '''
            tell application "MindManager"
                try
                    balance map of document 1
                end try
            end tell
        '''
        _run_applescript(script_balance)

        # Activate MindManager
        script_activate = '''
            tell application "MindManager"
                activate
            end tell
        '''
        _run_applescript(script_activate)

        # Optionally merge all windows
        if self.MACOS_MERGE_ALL_WINDOWS:
            self.merge_windows()

        # No persistent object references to clear
        pass



================================================
File: mindm/mindmanager_win.py
================================================
"""
Windows-specific implementation of the Mindmanager interface.

This module provides Windows platform-specific implementation for interacting
with MindManager application, including functionality for manipulating topics,
properties, relationships, and document structure.
"""

import os
import win32com.client
import winreg
import tempfile

from mindmap.mindmap import MindmapLink, MindmapImage, MindmapNotes, MindmapIcon, MindmapTag, MindmapReference, MindmapTopic

class Mindmanager:

    @staticmethod
    def get_mindmanager_version():
        versions = ["26", "25", "24", "23", "22", "21", "20"]
        for version in versions:
            try:
                key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, f"Software\\Mindjet\\MindManager\\{version}\\AddIns")
                winreg.CloseKey(key)
                return version
            except FileNotFoundError:
                continue
        return None

    mindmanager_version = get_mindmanager_version()
    if mindmanager_version:
        WINDOWS_LIBRARY_FOLDER = os.path.join(os.environ.get("LOCALAPPDATA", ""), "Mindjet", "MindManager", mindmanager_version, "Library", "ENU")
    else:
        raise Exception("No MindManager version registry keys found.")

    def __init__(self, charttype):
        self._version = Mindmanager.get_mindmanager_version()
        self._mindmanager = win32com.client.Dispatch("Mindmanager.Application")
        self._mindmanager.Options.BalanceNewMainTopics = True
        self._charttype = charttype
        self._library_folder = self.WINDOWS_LIBRARY_FOLDER
        self._document = self._mindmanager.ActiveDocument
    
    def get_mindmanager_object(self):
        return self._mindmanager
        
    def get_active_document_object(self):
        return self._mindmanager.ActiveDocument
        
    def get_library_folder(self):
        return self._library_folder

    def get_version(self):
        return self._version

    def set_document_background_image(self, path):
        try:
            background = self._document.Background
            if background.HasImage:
                background.RemoveImage()
            background.InsertImage(path)
            background.TileOption = 1  # center
            background.Transparency = 88
        except Exception as e:
            print(f"Error setting document background image: {e}")

    def document_exists(self):
        try:
            return True if self._document else False
        except Exception as e:
            print(f"Error checking document existence: {e}")
            return False

    def get_central_topic(self) -> 'MindmapTopic':
        try:
            topic = self._document.CentralTopic
            return self.get_mindmaptopic_from_topic(topic)
        except Exception as e:
            raise Exception(f"Error getting central topic: {e}")
        
    def get_mindmaptopic_from_topic(self, topic) -> 'MindmapTopic':
        mindmap_topic = MindmapTopic()
        mindmap_topic.guid=self.get_guid_from_topic(topic)
        mindmap_topic.text=self.get_text_from_topic(topic)
        mindmap_topic.rtf=self.get_title_from_topic(topic)
        mindmap_topic.level=self.get_level_from_topic(topic)
        return mindmap_topic
    
    def get_mindmaptopic_from_topic_content(self, topic) -> 'MindmapTopic':
        mindmap_topic = self.get_mindmaptopic_from_topic(topic)
        mindmap_topic.notes = self.get_notes_from_topic(topic)
        return mindmap_topic
    
    def get_mindmaptopic_from_topic_full(self, topic) -> 'MindmapTopic':
        mindmap_topic = self.get_mindmaptopic_from_topic(topic)
        mindmap_topic.notes = self.get_notes_from_topic(topic)
        mindmap_topic.links = self.get_links_from_topic(topic)
        mindmap_topic.image = self.get_image_from_topic(topic)
        mindmap_topic.icons = self.get_icons_from_topic(topic)
        mindmap_topic.tags = self.get_tags_from_topic(topic)
        mindmap_topic.references = self.get_references_from_topic(topic)
        return mindmap_topic
    
    def get_topic_by_id(self, id):
        try:
            return self._document.FindByGuid(id)
        except Exception as e:
            print(f"Error in get_topic_by_id: {e}")
            return None

    def get_selection(self):
        selection = []
        try:
            objs = self._document.Selection
            for obj in objs:
                try:
                    class_name = obj._oleobj_.GetTypeInfo().GetDocumentation(-1)[0]
                    if class_name == "ITopic":
                        selection.append(obj)
                except Exception as e:
                    print(f"Error in get_selection, getting class name: {e}")
                    continue
        except Exception as e:
            print(f"Error in get_selection: {e}")
        return selection

    def get_level_from_topic(self, topic):
        try:
            return topic.Level
        except Exception as e:
            print(f"Error in get_level_from_topic: {e}")
            return None

    def get_text_from_topic(self, topic):
        try:
            return topic.Text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        except Exception as e:
            print(f"Error in get_text_from_topic: {e}")
            return ""

    def get_title_from_topic(self, topic):
        try:
            title = topic.Title
            text = title.TextRTF if title.TextRTF != '' else ''
            return text
        except Exception as e:
            print(f"Error in get_title_from_topic: {e}")
            return ""

    def get_subtopics_from_topic(self, topic):
        try:
            return topic.AllSubTopics
        except Exception as e:
            print(f"Error in get_subtopics_from_topic: {e}")
            return None
    
    def get_links_from_topic(self, topic) -> list[MindmapLink]:
        hyperlinks = []
        try:
            if topic.HasHyperlink:
                for hyperlink in topic.Hyperlinks:
                    link = MindmapLink(
                        text=hyperlink.Title,
                        url=hyperlink.Address,
                        guid=hyperlink.TopicLabelGuid
                    )
                    hyperlinks.append(link)
        except Exception as e:
            print(f"Error in get_links_from_topic: {e}")
        return hyperlinks

    def get_image_from_topic(self, topic) -> MindmapImage:
        try:
            if topic.HasImage:
                image = topic.Image
                with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp:
                    temp_filename = tmp.name
                image.Save(temp_filename, 3)  # 3=PNG
                return MindmapImage(text=temp_filename)
        except Exception as e:
            print(f"Error in get_image_from_topic: {e}")
        return None

    def get_icons_from_topic(self, topic) -> list[MindmapIcon]:
        icons = []
        try:
            user_icons = topic.UserIcons
            if user_icons.Count > 0:
                for icon in user_icons:
                    if icon.Type == 1 and icon.IsValid == True:  # Stock Icon
                        icons.append(MindmapIcon(
                            text=icon.Name,
                            index=icon.StockIcon
                        ))
                    elif icon.Type == 2 and icon.IsValid == True:
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp:
                            temp_filename = tmp.name
                        icon.Save(temp_filename, 3)  # 3=PNG
                        icons.append(MindmapIcon(
                            text=icon.Name,
                            is_stock_icon=False,
                            signature=icon.CustomIconSignature,
                            path=temp_filename
                        ))
        except Exception as e:
            print(f"Error in get_icons_from_topic: {e}")
        return icons

    def get_notes_from_topic(self, topic) -> MindmapNotes:
        try:
            notes = topic.Notes
            topic_notes = None
            if notes:
                if notes.IsValid == True and not notes.IsEmpty:
                    topic_notes = MindmapNotes()
                    if notes.TextRTF != "":
                        topic_notes.rtf = notes.TextRTF
                    if notes.TextXHTML != "":
                        topic_notes.xhtml = notes.TextXHTML
                    if notes.Text != "":
                        topic_notes.text = notes.Text
            return topic_notes
        except Exception as e:
            print(f"Error in get_notes_from_topic: {e}")
            return None

    def get_tags_from_topic(self, topic) -> list[MindmapTag]:
        tags = []
        try:
            text_labels = topic.TextLabels
            if text_labels.Count > 0 and text_labels.IsValid == True:
                for text_label in text_labels:
                    if text_label.IsValid == True and text_label.GroupId == "":
                        tags.append(MindmapTag(text=text_label.Name))
        except Exception as e:
            print(f"Error in get_tags_from_topic: {e}")
        return tags

    def get_references_from_topic(self, topic) -> list[MindmapReference]:
        references = []
        try:
            relationships = topic.AllRelationships
            if relationships.Count > 0 and relationships.IsValid == True:
                for relation in relationships:
                    if relation.IsValid == True:
                        connected_topic_guid_1 = relation.ConnectedObject1
                        connected_topic_guid_2 = relation.ConnectedObject2
                        reference_direction = 1 if connected_topic_guid_1 == topic else 2
                        references.append(MindmapReference(
                            guid_1=str(connected_topic_guid_1.Guid),
                            guid_2=str(connected_topic_guid_2.Guid),
                            direction=reference_direction,
                            label=''
                        ))
        except Exception as e:
            print(f"Error in get_references_from_topic: {e}")
        return references
    
    def get_guid_from_topic(self, topic) -> str:
        try:
            return topic.Guid
        except Exception as e:
            print(f"Error in get_guid_from_topic: {e}")
            return ""
        
    def add_subtopic_to_topic(self, topic, topic_text):
        try:
            return topic.AddSubtopic(topic_text)
        except Exception as e:
            print(f"Error in add_subtopic_to_topic: {e}")
            return None

    def get_parent_from_topic(self, topic):
        try:
            return topic.ParentTopic
        except Exception as e:
            print(f"Error in get_parent_from_topic: {e}")
            return None

    def set_text_to_topic(self, topic, topic_text):
        try:
            topic.Text = topic_text
        except Exception as e:
            print(f"Error in set_text_to_topic: {e}")

    def set_title_to_topic(self, topic, topic_rtf):
        try:
            if topic_rtf != "":
                topic.Title.TextRTF = topic_rtf
        except Exception as e:
            print(f"Error in set_title_to_topic: {e}")

    def add_tag_to_topic(self, topic=None, tag_text='', topic_guid=None):
        try:
            if topic_guid:
                topic = self.get_topic_by_id(topic_guid)
            if topic:
                topic.TextLabels.AddTextLabelFromGroup(tag_text, '', True)
        except Exception as e:
            print(f"Error in add_tag_to_topic: {e}")

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons):
        self.set_text_to_topic(topic, mindmap_topic.text)
        self.set_title_to_topic(topic, mindmap_topic.rtf)
        self.add_tags_to_topic(topic, mindmap_topic.tags)
        self.set_notes_to_topic(topic, mindmap_topic.notes)
        self.add_icons_to_topic(topic, mindmap_topic.icons, map_icons)
        self.add_image_to_topic(topic, mindmap_topic.image)
        self.add_links_to_topic(topic, mindmap_topic.links)
        return topic, topic.Guid
    
    def add_links_to_topic(self, topic, mindmap_topic_links):
        try:
            if mindmap_topic_links:
                for topic_link in mindmap_topic_links:
                    if topic_link.guid == "" and topic_link.url != "":
                        link = topic.Hyperlinks.AddHyperlink(topic_link.url)
                        link.Title = topic_link.text
        except Exception as e:
            print(f"Error in add_links_to_topic: {e}")

    def add_image_to_topic(self, topic, mindmap_topic_image):
        try:
            if mindmap_topic_image:
                topic.CreateImage(mindmap_topic_image.text)
        except Exception as e:
            print(f"Error in add_image_to_topic: {e}")

    def add_icons_to_topic(self, topic, mindmap_topic_icons, map_icons):
        try:
            if len(mindmap_topic_icons) > 0:
                for topic_icon in mindmap_topic_icons:
                    if topic_icon.is_stock_icon:
                        topic.UserIcons.AddStockIcon(topic_icon.index)
                    else:
                        if len(map_icons) > 0 and topic_icon.signature != "":
                            topic.UserIcons.AddCustomIconFromMap(topic_icon.signature)
                        else:
                            if os.path.exists(topic_icon.path):
                                topic.UserIcons.AddCustomIcon(topic_icon.path)
        except Exception as e:
            print(f"Error in add_icons_to_topic: {e}")

    def set_notes_to_topic(self, topic, mindmap_topic_notes):
        try:
            if mindmap_topic_notes:
                if mindmap_topic_notes.text:
                    topic.Notes.Text = mindmap_topic_notes.text
                else:
                    if mindmap_topic_notes.xhtml:
                        try:
                            topic.Notes.TextXHTML = mindmap_topic_notes.xhtml
                        except Exception as e:
                            print(f"Error setting TextXHTML: {e}")
                            print(f"Topic: `{topic.Text}`")
                    else:
                        if mindmap_topic_notes.rtf:
                            topic.Notes.TextRTF = mindmap_topic_notes.rtf
        except Exception as e:
            print(f"Error in set_notes_to_topic: {e}")


    def add_tags_to_topic(self, topic, mindmap_topic_tags):
        try:
            if len(mindmap_topic_tags) > 0:
                for topic_tag in mindmap_topic_tags:
                    topic.TextLabels.AddTextLabelFromGroup(topic_tag.text, '', True)
        except Exception as e:
            print(f"Error in add_tags_to_topic: {e}")

    def create_map_icons(self, map_icons):
        try:
            if len(map_icons) > 0:
                icon_groups = set(map_icon.group for map_icon in map_icons if map_icon.group)
                for icon_group in icon_groups:
                    group = self._document.MapMarkerGroups.AddIconMarkerGroup(icon_group)
                    for map_icon in map_icons:
                        if map_icon.group == icon_group:
                            label = map_icon.text
                            marker = group.AddCustomIconMarker(label, map_icon.path)
                            map_icon.signature = marker.Icon.CustomIconSignature
        except Exception as e:
            print(f"Error in create_map_icons: {e}")

    def create_tags(self, tags: list['str'], DUPLICATED_TAG: str):
        try:
            if len(tags) > 0:
                map_marker_group = self._document.MapMarkerGroups.GetMandatoryMarkerGroup(10)
                for tag in tags:
                    map_marker_group.AddTextLabelMarker(tag)
                if DUPLICATED_TAG != '' and DUPLICATED_TAG not in tags:
                    map_marker_group.AddTextLabelMarker(DUPLICATED_TAG)
        except Exception as e:
            print(f"Error in create_tags: {e}")

    def add_relationship(self, guid1, guid2, label=''):
        try:
            object1 = self.get_topic_by_id(guid1)
            object2 = self.get_topic_by_id(guid2)
            if object1 and object2:
                if object1.ParentTopic == object2 or object2.ParentTopic == object1:
                    return
                object1.AllRelationships.AddToTopic(object2, label)
        except Exception as e:
            print(f"Error in add_relationship: {e}")

    def add_topic_link(self, guid1, guid2, label=''):
        try:
            object1 = self.get_topic_by_id(guid1)
            object2 = self.get_topic_by_id(guid2)
            if object1 and object2:
                hyperlinks = object1.Hyperlinks
                link = hyperlinks.AddHyperlinkToTopicByGuid(guid2)
                link.Title = label if label != "" else object2.Title.Text
        except Exception as e:
            print(f"Error in add_topic_link: {e}")

    def add_document(self, max_topic_level):
        try:
            style = self._document.StyleXml
            new_document = self._mindmanager.Documents.Add()
            new_document.StyleXml = style
            self._document = new_document
        except Exception as e:
            print(f"Error in add_document: {e}")

    def finalize(self, max_topic_level):
        try:
            centralTopic = self._document.CentralTopic
            layout = centralTopic.SubTopicsLayout
            growthDirection = layout.CentralTopicGrowthDirection
            cnt_subtopics = len(centralTopic.AllSubTopics)
                               
            # collapse/uncollapse outer topics
            if max_topic_level > 3:
                for topic in self._document.Range(2, True):  # 2 = all topics
                    if topic.Level > 2:
                        topic.Collapsed = True
                    else:
                        if topic.Level != 0:
                            topic.Collapsed = False
            else:
                for topic in self._document.Range(2, True):  # 2 = all topics
                    if topic.Level > 3:
                        topic.Collapsed = True
                    else:
                        if topic.Level != 0:
                            topic.Collapsed = False
                            
            # org chart            
            if self._charttype == "orgchart" or self._charttype == "auto":
                if max_topic_level > 2 and cnt_subtopics > 4:
                    if growthDirection == 1:
                        layout.CentralTopicGrowthDirection = 5
                        
            # radial map
            if self._charttype == "radial" or self._charttype == "auto":
                if max_topic_level > 2 and cnt_subtopics < 5:
                    if growthDirection != 1:
                        layout.CentralTopicGrowthDirection = 1
                if max_topic_level < 3 and cnt_subtopics > 4:
                    if growthDirection != 1:
                        layout.CentralTopicGrowthDirection = 1

            self._document.Zoom(1)
            self._mindmanager.Visible = True
        except Exception as e:
            print(f"Error in finalize: {e}")


================================================
File: mindm/as/read.applescript
================================================
use scripting additions

property SCRIPT_EDITOR_MODE : false
property parent : me

on run argv
	try
		return my handleCommand(argv)
	on error errMsg number errNum
		local basicEscapedMsg
		try
			set basicEscapedMsg to my escapeJSON(errMsg as text)
		on error
			set basicEscapedMsg to "Error message could not be escaped."
		end try
		return "{ \"error\": \"Top-level script error: " & basicEscapedMsg & " (Code: " & errNum & ")\" }"
	end try
end run

on handleCommand(argv)
	if (count of argv) is 0 then
		if SCRIPT_EDITOR_MODE then
			-- set testResult to my handleCommand({"getSelection"})
			set testResult to my handleCommand({"getTree", ""})
			-- set testResult to my handleCommand({"getTree", "5C9B484E-3AAF-914B-A721-3BD81BA790CF"})
			-- set testResult to my handleCommand({"getListProperties", "5C9B484E-3AAF-914B-A721-3BD81BA790CF", "9C0E27E6-BC9C-7546-93E9-617B79C9ACA1"})
			-- set testResult to my handleCommand({"getSingleProperties", "87189219-194F-A549-AE08-BF94E1BF590A"})
			return testResult
		else
			return "{ \"error\": \"No operation mode specified.\" }"
		end if
	end if
	
	set operationMode to item 1 of argv
	set operationArgs to rest of argv
	
	if operationMode is "getSingleProperties" or operationMode is "getTree" or operationMode is "getListProperties" or operationMode is "getSelection" then
		try
			tell application "MindManager"
				if not running then error "MindManager application is not running." number -1708
				if (count of documents) is 0 then error "No MindManager document is open."
			end tell
		on error checkErr number checkErrNum
			return "{ \"error\": \"MindManager Access Check Failed: " & my escapeJSON(checkErr) & " (Code: " & checkErrNum & ")\" }"
		end try
	end if
	
	try
		if operationMode is "getSingleProperties" then
			if (count of operationArgs) is not 1 then return "{ \"error\": \"Mode 'getSingleProperties' requires exactly 1 argument (topicID).\" }"
			set topicID to item 1 of operationArgs
			return my doGetSingleProperties(topicID)

		else if operationMode is "getSelection" then
			if (count of operationArgs) is not 0 then return "{ \"error\": \"Mode 'getSelection' does not require any arguments.\" }"
			return my doGetSelection()

		else if operationMode is "getTree" then
			local startTopicID, theStartTopic
			if (count of operationArgs) is 0 or item 1 of operationArgs is "" or item 1 of operationArgs is " " then
				set theStartTopic to my _getCentralTopic()
				if theStartTopic is missing value then return "{ \"error\": \"Could not retrieve the central topic.\" }"
			else
				if (count of operationArgs) is not 1 then return "{ \"error\": \"Mode 'getTree' requires 0 or 1 argument (optional topicID).\" }" # Corrected error message
				set startTopicID to item 1 of operationArgs
				set theStartTopic to my _findTopicByID(startTopicID)
				if theStartTopic is missing value then return "{ \"error\": \"Starting topic for tree not found with ID: " & my escapeJSON(startTopicID) & "\" }"
			end if
			return my doGetTree(theStartTopic)
			
		else if operationMode is "getListProperties" then
			if (count of operationArgs) is 0 then return "{ \"error\": \"Mode 'getListProperties' requires at least 1 argument (topicID list).\" }"
			return my doGetListProperties(operationArgs)
		else
			return "{ \"error\": \"Unknown operation mode: " & my escapeJSON(operationMode) & "\" }"
		end if
		
	on error errMsg number errNum
		return "{ \"error\": \"Execution failed for mode '" & my escapeJSON(operationMode) & "': " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end handleCommand

on doGetSelection()
    -- ask once, outside the repeat, for performance and to keep the
    -- try/on?error scope tight
    try
        tell application "MindManager"
            set selItems to selection of document 1 -- this is a LIST
        end tell
    on error errMsg number errNum
        return "{\"error\":\"Could not fetch selection: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\"}"
    end try
    
    if selItems is {} then return "[]" -- nothing is highlighted
    
    set jsonObjects to {}
    repeat with oneItem in selItems
        try
            -- will raise an error if oneItem is not a topic
            set end of jsonObjects to my doGetSingleProperties(id of oneItem)
        end try
    end repeat
    
    -- build the JSON array
    set AppleScript's text item delimiters to ","
    set finalJSON to "[" & (jsonObjects as text) & "]"
    set AppleScript's text item delimiters to ""
    return finalJSON
end doGetSelection

-- Mode 1: Get properties for a single topic ID
on doGetSingleProperties(topicID as string)
	if topicID is "" then return "{ \"error\": \"Empty topic ID provided.\" }"
	
	set theTopic to my _findTopicByID(topicID)
	if theTopic is missing value then
		return "{ \"error\": \"Topic with ID '" & my escapeJSON(topicID) & "' not found.\" }"
	end if
	
	try
		set propertiesRecord to my _get_topic_properties_record(theTopic, topicID)
		if errorStatus of propertiesRecord is true then
			return "{ \"error\": \"Error fetching properties for ID '" & my escapeJSON(topicID) & "': " & my escapeJSON(errorMsg of propertiesRecord) & "\" }"
		end if
		
		set escapedID to my escapeJSON(topicID)
		set escapedName to my escapeJSON(propName of propertiesRecord)
		set escapedNotes to my escapeJSON(propNotes of propertiesRecord)
		set propLevel to propLevel of propertiesRecord
		
		return "{\"guid\":\"" & escapedID & "\", \"text\":\"" & escapedName & "\", \"level\":" & propLevel & ", \"notes\":\"" & escapedNotes & "\"}"
	on error errMsg number errNum
		return "{ \"guid\":\"" & my escapeJSON(topicID) & "\", \"error\": \"Unexpected error in doGetSingleProperties: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end doGetSingleProperties

-- Mode 2: Get the topic tree starting from a specific topic
on doGetTree(startTopic)
	try
		return my _buildTreeRecursive(startTopic)
	on error errMsg number errNum
		local startTopicID
		try
			tell application "MindManager" to set startTopicID to id of startTopic
		on error
			set startTopicID to "[unknown]"
		end try
		return "{ \"error\": \"Error building tree starting from topic " & startTopicID & ": " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end doGetTree

-- Mode 3: Get properties for a list of topic IDs
on doGetListProperties(topicIDList as list)
	set resultsList to {}
	set errorsEncountered to {}
	
	set oldTID to AppleScript's text item delimiters
	set AppleScript's text item delimiters to "," 
	
	repeat with currentTopicID in topicIDList
		set currentTopicID_str to ""
		try
			set currentTopicID_str to currentTopicID as string
			if currentTopicID_str is "" then
				error "Empty topic ID encountered in list."
			end if
			
			set theTopic to my _findTopicByID(currentTopicID_str)
			
			if theTopic is missing value then
				set end of errorsEncountered to "Topic ID '" & my escapeJSON(currentTopicID_str) & "' not found."
			else
				try
					set propertiesRecord to my _get_topic_properties_record(theTopic, currentTopicID_str)
					if errorStatus of propertiesRecord is true then
						set end of errorsEncountered to "Error fetching properties for ID '" & my escapeJSON(currentTopicID_str) & "': " & my escapeJSON(errorMsg of propertiesRecord)
					else
						set escapedID to my escapeJSON(currentTopicID_str)
						set escapedName to my escapeJSON(propName of propertiesRecord)
						set escapedNotes to my escapeJSON(propNotes of propertiesRecord)
						set propLevel to propLevel of propertiesRecord
						set jsonObject to "{\"guid\":\"" & escapedID & "\", \"text\":\"" & escapedName & "\", \"level\":" & propLevel & ", \"notes\":\"" & escapedNotes & "\"}"
						set end of resultsList to jsonObject
					end if
				on error errMsg number errNum
					set end of errorsEncountered to "Error processing topic ID '" & my escapeJSON(currentTopicID_str) & "': " & my escapeJSON(errMsg) & " (Code: " & errNum & ")"
				end try
			end if
			
		on error errItemMsg number errItemNum
			local nonStringErr
			try
				set nonStringErr to class of currentTopicID
			on error
				set nonStringErr to "unknown type"
			end try
			if currentTopicID_str is "" and errItemMsg contains "Cannot make" then
				set end of errorsEncountered to "Invalid item in topic ID list (not text, type: " & nonStringErr & ", value: " & (currentTopicID as text) & ")"
			else
				set end of errorsEncountered to errItemMsg & " (Code: " & errItemNum & ")"
			end if
		end try
	end repeat
	
	set finalJSON to "[" & (resultsList as text) & "]"
	set AppleScript's text item delimiters to oldTID
	
	if (count of errorsEncountered) > 0 then
		log "--- Errors encountered during getListProperties ---"
		repeat with errItem in errorsEncountered
			log errItem
		end repeat
		log "--- End Errors ---"
	end if
	
	return finalJSON
end doGetListProperties


on _buildTreeRecursive(aTopic)
	local topicID, propertiesRecord, tID_escaped, tName_escaped, tLevel, tNotes_escaped, childJSONs, childTopicObjects, childTopic, jsonText, oldTID, idErr, childErr
	
	set topicID to missing value
	try
		tell application "MindManager" to set topicID to id of aTopic
	on error idErr
		log "Critical Error: Failed to get ID for a topic object during tree build: " & (idErr as text)
		return "{ \"error\": \"Failed to get ID for a topic object. Cannot proceed with this branch.\" }"
	end try
	
	set propertiesRecord to my _get_topic_properties_record(aTopic, topicID)
	
	set tID_escaped to my escapeJSON(topicID)
	if errorStatus of propertiesRecord is true then
		set tName_escaped to "\"<Error fetching name>\""
		set tLevel to -1
		set tNotes_escaped to my escapeJSON("Property Error: " & (errorMsg of propertiesRecord))
		log "Warning: Properties fetch failed for topic " & topicID & " during tree build: " & errorMsg of propertiesRecord
	else
		set tName_escaped to my escapeJSON(propName of propertiesRecord)
		set tLevel to propLevel of propertiesRecord
		set tNotes_escaped to my escapeJSON(propNotes of propertiesRecord)
	end if
	
	set childJSONs to {}
	set childTopicObjects to my _get_subtopics_objects(aTopic, topicID)
	if childTopicObjects is not missing value then
		repeat with childTopic in childTopicObjects
			try
				set end of childJSONs to my _buildTreeRecursive(childTopic)
			on error childErr number childErrNum
				log "Error processing child during recursion for parent " & topicID & ": " & childErr & " (" & childErrNum & ")"
				set end of childJSONs to "{ \"error\": \"Error processing child topic: " & my escapeJSON(childErr as text) & "\" }"
			end try
		end repeat
	else
		set childJSONs to {"{ \"error\": \"Could not retrieve subtopics for topic " & tID_escaped & "\" }"}
	end if
	
	set oldTID to AppleScript's text item delimiters
	set AppleScript's text item delimiters to ","
	set jsonText to "{\"guid\":\"" & tID_escaped & "\", \"text\":\"" & tName_escaped & "\", \"level\":" & tLevel & ", \"notes\":\"" & tNotes_escaped & "\", \"subtopics\":[" & (childJSONs as text) & "]}"
	set AppleScript's text item delimiters to oldTID
	
	return jsonText
end _buildTreeRecursive

on _get_topic_properties_record(theTopic, topicIDForError)
	local propName, propLevel, propNotesText, mainErr, levelErr, notesErr, nameErr
	
	set propName to "[Name Error]"
	set propLevel to -1
	set propNotesText to ""
	set errorStatus to false
	set errorMsg to ""
	
	try
		if theTopic is missing value then error "Invalid topic object provided."
		
		tell application "MindManager"
			try
				set propName to name of theTopic
			on error nameErr
				set errorStatus to true
				set errorMsg to errorMsg & "Failed to get name. "
				log "Warning (_get_topic_properties_record): Could not get name for topic " & topicIDForError & ": " & (nameErr as rich text)
			end try
			
			try
				set propLevel to level of theTopic
			on error levelErr
				set errorStatus to true
				set errorMsg to errorMsg & "Failed to get level. "
				log "Warning (_get_topic_properties_record): Could not get level for topic " & topicIDForError & ": " & (levelErr as rich text)
			end try
			
			try
				set propNotesText to notes of theTopic as rich text
			on error notesErr
				set propNotesText to ""
				set errorMsg to errorMsg & "Failed to get notes. "
				log "Warning (_get_topic_properties_record): Could not get notes for topic " & topicIDForError & ": " & (notesErr as rich text) & " (" & (number of notesErr) & ")"
			end try
		end tell
		
		if errorStatus then
			return {errorStatus:true, errorMsg:errorMsg, propName:propName, propLevel:propLevel, propNotes:propNotesText}
		else
			return {errorStatus:false, propName:propName, propLevel:propLevel, propNotes:propNotesText}
		end if
		
	on error mainErr number mainErrNum
		return {errorStatus:true, errorMsg:"Unexpected error in _get_topic_properties_record for " & topicIDForError & ": " & (mainErr as text) & " (Code: " & mainErrNum & ")", propName:"", propLevel:-1, propNotes:""}
	end try
end _get_topic_properties_record

on _get_subtopics_objects(parentTopic, parentIDForLog)
	local childList, childErr, attempt
	set childList to missing value
	try
		if parentTopic is missing value then error "Invalid parent topic object provided."
		tell application "MindManager"
			tell parentTopic
				try
					set childList to every subtopic
					return childList
				on error childErr
					log "Info (" & parentIDForLog & "): _get_subtopics_objects ('every subtopic') failed: " & (childErr as rich text)
				end try
			end tell
		end tell
		if childList is missing value then
			log "Error getting subtopics for topic ID '" & parentIDForLog & "': All attempts failed."
			return missing value
		else
			log "Warning (" & parentIDForLog & "): Reached end of _get_subtopics_objects unexpectedly. Returning empty list."
			return {}
		end if
	on error mainErr number mainErrNum
		log "Critical error in _get_subtopics_objects for topic ID '" & parentIDForLog & "': " & (mainErr as text) & " (Code: " & mainErrNum & ")"
		return missing value
	end try
end _get_subtopics_objects

on _findTopicByID(targetID as string)
	if targetID is "" then return missing value
	try
		tell application "MindManager"
			tell document 1
				if id of central topic is targetID then return central topic
				try
					set foundTopics to (every topic whose id is targetID)
					if (count of foundTopics) > 0 then
						return item 1 of foundTopics
					else
						return missing value
					end if
				on error findErr number findErrNum
					if findErrNum is -1728 then
						return missing value
					else
						log "Error using 'whose' clause in _findTopicByID for ID " & targetID & ": " & findErr & " (" & findErrNum & ")"
						error "MindManager search failed unexpectedly." number findErrNum
					end if
				end try
			end tell
		end tell
	on error errMsg number errNum
		log "Error in _findTopicByID searching for " & targetID & ": " & (errMsg as text) & " (Code: " & errNum & ")"
		return missing value
	end try
end _findTopicByID

on _getCentralTopic()
	try
		tell application "MindManager"
			if not running or (count of documents) is 0 then return missing value
			return central topic of document 1
		end tell
	on error errMsg number errNum
		log "Error getting central topic: " & errMsg & " (" & errNum & ")"
		return missing value
	end try
end _getCentralTopic

on escapeJSON(txt)
	local originalDelimiters, textItems, theClass
	try
		set theClass to class of txt
		if theClass is not text and theClass is not string then
			set txt to txt as text
		end if
	on error
		if txt is missing value then return ""
		log "Warning: escapeJSON received non-text data: " & (txt as text)
		return "[Error: Non-text data]"
	end try
	set originalDelimiters to AppleScript's text item delimiters
	try
		set AppleScript's text item delimiters to "\\"
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\\\"
		set txt to textItems as text
		set AppleScript's text item delimiters to "\""
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\\""
		set txt to textItems as text
		set AppleScript's text item delimiters to "/"
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\/"
		set txt to textItems as text
		set AppleScript's text item delimiters to return & linefeed
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to return
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to linefeed
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to tab
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\t"
		set txt to textItems as text
		set AppleScript's text item delimiters to originalDelimiters
		return txt
	on error e
		set AppleScript's text item delimiters to originalDelimiters
		return "[\"Error during JSON escaping: " & (e as text) & "\"]"
	end try
end escapeJSON



================================================
File: mindm/as/read.scpt
================================================
[Non-text file]


================================================
File: mindm/as/write.applescript
================================================
use framework "Foundation"
use scripting additions

property SCRIPT_EDITOR_MODE : false
property parent : me
property NSString : a reference to current application's NSString
property NSJSONSerialization : a reference to current application's NSJSONSerialization
property NSNull : a reference to current application's NSNull
property NSArray : a reference to current application's NSArray
property NSDictionary : a reference to current application's NSDictionary
property NSUTF8StringEncoding : a reference to current application's NSUTF8StringEncoding

on run argv
	try
		return my handleCommand(argv)
	on error errMsg number errNum
		local basicEscapedMsg
		try
			set basicEscapedMsg to my escapeJSON(errMsg as text)
		on error
			set basicEscapedMsg to "Error message could not be escaped."
		end try
		return "{ \"error\": \"Top-level script error: " & basicEscapedMsg & " (Code: " & errNum & ")\" }"
	end try
end run

on handleCommand(argv)
	if (count of argv) is 0 then
		if SCRIPT_EDITOR_MODE then
			set testResult to my handleCommand({"writeTree", "{\"guid\": \"F35D6F0A-916B-4BD4-B6C5-6FD3B8873421\", \"text\": \"Creating an AI startup\", \"subtopics\": [{\"guid\": \"AABE2CFB-E72E-47DB-8358-FEDF652384AF\", \"text\": \"Vision & Strategy\", \"subtopics\": [{\"guid\": \"6EC7E029-8AAF-4F95-A4F7-2DF9FC9C274E\", \"text\": \"Mission & Value\", \"subtopics\": [{\"guid\": \"62753394-43CF-4EA4-9D11-32A0B01B2316\", \"text\": \"Problem Statement\"}, {\"guid\": \"3702BC7C-F340-4915-9B9C-EA7723168674\", \"text\": \"Value Proposition\"}, {\"guid\": \"2B1EABD7-8DA6-477D-9066-26E33AD8465E\", \"text\": \"Target Outcomes\"}]}, {\"guid\": \"BE661CA1-ADC8-42F4-AC12-2F86ABC965CB\", \"text\": \"Market Positioning\", \"subtopics\": [{\"guid\": \"63B699E2-743E-4586-87E6-ABD87D6486BE\", \"text\": \"Differentiation\"}, {\"guid\": \"02033FA2-8748-4B88-9D75-9D2913781E55\", \"text\": \"Target Segments\"}, {\"guid\": \"369BD38C-859B-4FCF-8AFA-8D1529E3659A\", \"text\": \"Competitive Edge\"}]}, {\"guid\": \"ECE4A5EA-883F-43FA-AAD8-DF7A8DE9A6EF\", \"text\": \"Roadmap Planning\", \"subtopics\": [{\"guid\": \"348D9A7A-F46B-40ED-A484-5481831CFBF3\", \"text\": \"Milestones\"}, {\"guid\": \"5E54DBFF-924D-494E-B792-48C27C78A67A\", \"text\": \"Success Metrics\"}]}]}, {\"guid\": \"012909AC-7D04-4066-84BF-DA1F34F50A27\", \"text\": \"Product Development\", \"subtopics\": [{\"guid\": \"BC2B8FF2-40D1-4298-8874-F6CD74BF6830\", \"text\": \"MVP Design\", \"subtopics\": [{\"guid\": \"8131DB69-6557-426F-8F2D-634CEB5563F9\", \"text\": \"Core Features\"}, {\"guid\": \"141446D1-9C6B-4810-B20B-D90E90B6CCBD\", \"text\": \"User Flows\"}, {\"guid\": \"F1F35599-2CFB-4F53-948C-158A9D7FE4EC\", \"text\": \"Success Criteria\"}]}, {\"guid\": \"833ECBF0-448B-40CC-BF87-DD4924A3FEAA\", \"text\": \"Data Strategy\", \"subtopics\": [{\"guid\": \"E11F6404-22D2-4D60-AB3D-F52898F088F5\", \"text\": \"Data Sources\"}, {\"guid\": \"19D2CDBD-6EEA-408D-A2E1-BF96E9E1E7C1\", \"text\": \"Labeling Plan\"}, {\"guid\": \"55D19F0B-1792-49FF-8A75-1DCFFAC1428A\", \"text\": \"Privacy Controls\"}]}, {\"guid\": \"3DD1CAEA-3B37-43E7-87C1-C3DFA22B3723\", \"text\": \"Model Lifecycle\", \"subtopics\": [{\"guid\": \"526F23CC-C658-4A9F-A894-76689A3B7CDB\", \"text\": \"Training Pipeline\"}, {\"guid\": \"46541951-9D8D-43A3-8246-5204F973B2F8\", \"text\": \"Evaluation Metrics\"}, {\"guid\": \"82A7CF2A-8D63-4A3B-9D54-4ADA1AB6FBEF\", \"text\": \"Iteration Plan\"}]}]}, {\"guid\": \"57DC272F-01E9-4B2A-B527-BE09A4380656\", \"text\": \"Team & Hiring\", \"subtopics\": [{\"guid\": \"9B3F327D-D163-4D6B-BE58-2F48C95D70D8\", \"text\": \"Founding Roles\", \"subtopics\": [{\"guid\": \"84D826FD-0439-4830-B00F-94CDD66D3BD0\", \"text\": \"CEO Responsibilities\"}, {\"guid\": \"6684A509-97EA-4458-9E10-60269A49389A\", \"text\": \"CTO Responsibilities\"}, {\"guid\": \"7B0D894C-36B1-49FB-8087-FB1C2EB5DD30\", \"text\": \"Product Lead Duties\"}]}, {\"guid\": \"E02B460A-02C1-4806-92DF-60FA8A1D96FA\", \"text\": \"Recruiting Plan\", \"subtopics\": [{\"guid\": \"888565DE-8B5C-4CE9-8CF3-5D7D1F7EF59B\", \"text\": \"Hiring Channels\"}, {\"guid\": \"4C4556A4-CC61-44F3-8BED-642DD034D2DA\", \"text\": \"Interview Process\"}]}, {\"guid\": \"89A17160-7CE0-460B-AAC0-E5D34C3D1CC0\", \"text\": \"Culture & Ops\", \"subtopics\": [{\"guid\": \"7CA6AC28-CC46-4290-A2C4-58221AA8DC92\", \"text\": \"Remote Policies\"}, {\"guid\": \"23A9F25C-4DD6-42DA-BEE7-02D542A88B95\", \"text\": \"Performance Reviews\"}]}]}, {\"guid\": \"33B58ECF-87BB-4A55-A1DF-0B9B8BFAB28C\", \"text\": \"Fundraising\", \"subtopics\": [{\"guid\": \"AF86A2B5-24AD-4C5B-9A47-B989B95D7DAB\", \"text\": \"Funding Strategy\", \"subtopics\": [{\"guid\": \"74CDCA7A-4FD5-4582-B3AB-0AD31EC3D9F3\", \"text\": \"Bootstrapping Plan\"}, {\"guid\": \"B8259997-4415-4E28-A22A-F7A7A50C3723\", \"text\": \"VC Pitch Focus\"}, {\"guid\": \"1F1F0714-4563-4A0E-8A23-05A5959F10FB\", \"text\": \"Angel Outreach\"}]}, {\"guid\": \"C088D7C0-536C-4D74-B0F8-411A70715A8F\", \"text\": \"Financial Planning\", \"subtopics\": [{\"guid\": \"0A837281-42C0-454B-80A7-E5D6009200BE\", \"text\": \"Burn Rate\"}, {\"guid\": \"56A17032-929C-4879-AAEC-2AEB56CECE45\", \"text\": \"Runway Management\"}, {\"guid\": \"26737FCB-647C-4919-8C1E-CF04DB82798A\", \"text\": \"Forecasts\"}]}, {\"guid\": \"B2040CFC-9B8A-4A81-AFB2-77ABA252AFD8\", \"text\": \"Investor Relations\", \"subtopics\": [{\"guid\": \"02F5F4D1-6333-491D-8473-7DA8CC17063F\", \"text\": \"Cap Table Management\"}, {\"guid\": \"854288EC-E443-4488-8EEC-E9266B3C764B\", \"text\": \"Demo Day Prep\"}]}]}, {\"guid\": \"00DCEE21-DF78-4994-B54A-719E34711383\", \"text\": \"Go-to-Market\", \"subtopics\": [{\"guid\": \"3F5AA657-3BC4-4A73-A808-76E497A6A350\", \"text\": \"Pricing Model\", \"subtopics\": [{\"guid\": \"AC53DAE8-4833-4A61-B6D6-DC0E3E8EBAC6\", \"text\": \"Subscription Plans\"}, {\"guid\": \"14430046-C744-4BBC-8EDA-563C18645FB1\", \"text\": \"Enterprise Pricing\"}]}, {\"guid\": \"CDF9F7D0-19B0-421D-ABD4-88BBB6FD1A16\", \"text\": \"Sales Strategy\", \"subtopics\": [{\"guid\": \"2909B9F8-6702-4F13-8E0E-4607077D3456\", \"text\": \"ICP Definition\"}, {\"guid\": \"070070AE-E98B-4F62-84EE-78958ED33CFE\", \"text\": \"Pipeline Management\"}, {\"guid\": \"F4E18FB4-CD26-4EDB-B5BC-158BBB526A64\", \"text\": \"Sales Hiring\"}]}, {\"guid\": \"F917AFF5-A2B7-4945-A0CD-E6229A8F5B5E\", \"text\": \"Marketing Plan\", \"subtopics\": [{\"guid\": \"A97358A2-D7DE-49F6-B511-4DAF6FAFB0D4\", \"text\": \"Content Strategy\"}, {\"guid\": \"63711491-91BB-4C68-A723-FCD075536FD1\", \"text\": \"Demand Gen Channels\"}, {\"guid\": \"AAC055E2-6CED-47F1-8B48-5E568858DFBA\", \"text\": \"PR & Partnerships\"}]}]}]}"})
			-- set testResult to my handleCommand({"writeTree", "{\"guid\":\"test-guid\", \"text\":\"Test Topic\", \"level\":0, \"notes\":\"Test notes\", \"subtopics\":[]}"})
			-- set testResult to my handleCommand({"setProperties", "{\"guid\":\"existing-guid\", \"text\":\"Updated Text\", \"level\":1, \"notes\":\"Updated notes\"}"})
			return testResult
		else
			return "{ \"error\": \"No operation mode specified.\" }"
		end if
	end if

	set operationMode to item 1 of argv
	set operationArgs to rest of argv

	if operationMode is "writeTree" or operationMode is "writeFragment" or operationMode is "setProperties" then
		try
			tell application "MindManager"
				if not running then error "MindManager application is not running." number -1708
				if (count of documents) is 0 then error "No MindManager document is open."
			end tell
		on error checkErr number checkErrNum
			return "{ \"error\": \"MindManager Access Check Failed: " & my escapeJSON(checkErr) & " (Code: " & checkErrNum & ")\" }"
		end try
	end if
	
	try
		if operationMode is "writeTree" then
			if (count of operationArgs) is not 1 then return "{ \"error\": \"Mode 'writeTree' requires exactly 1 argument (JSON data).\" }"
			set jsonData to item 1 of operationArgs
			return my doWriteTree(jsonData)
			
		else if operationMode is "writeFragment" then
			if (count of operationArgs) is not 1 then return "{ \"error\": \"Mode 'writeFragment' requires exactly 1 argument (JSON data).\" }"
			set jsonData to item 1 of operationArgs
			return my doWriteFragment(jsonData)
			
		else if operationMode is "setProperties" then
			if (count of operationArgs) is not 1 then return "{ \"error\": \"Mode 'setProperties' requires exactly 1 argument (JSON data).\" }"
			set jsonData to item 1 of operationArgs
			return my doSetProperties(jsonData)
			
		else
			return "{ \"error\": \"Unknown operation mode: " & my escapeJSON(operationMode) & "\" }"
		end if
		
	on error errMsg number errNum
		return "{ \"error\": \"Execution failed for mode '" & my escapeJSON(operationMode) & "': " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end handleCommand

on doWriteTree(jsonData)
	try
		-- Parse the JSON and create a new document with the tree structure
		set parsedData to my parseTopicJSON(jsonData)
		if errorStatus of parsedData is true then
			return "{ \"error\": \"JSON parsing failed: " & my escapeJSON(errorMsg of parsedData) & "\" }"
		end if
		
		tell application "MindManager"
			-- Create new document or clear existing one
			if (count of documents) > 0 then
				tell document 1
					set name of central topic to topicText of parsedData
					if topicNotes of parsedData is not "" then
						set notes of central topic to topicNotes of parsedData
					end if
					-- Remove existing subtopics
					delete every subtopic of central topic
				end tell
			else
				make new document
				tell document 1
					set name of central topic to topicText of parsedData
					if topicNotes of parsedData is not "" then
						set notes of central topic to topicNotes of parsedData
					end if
				end tell
			end if
			
			-- Build the tree structure recursively
			set result to my buildTreeFromJSON(central topic of document 1, topicSubtopics of parsedData)
			if result contains "error" then
				return result
			end if
		end tell
		
		return "{ \"success\": \"Tree written successfully\" }"
		
	on error errMsg number errNum
		return "{ \"error\": \"Error in doWriteTree: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end doWriteTree

on doWriteFragment(jsonData)
	try
		-- Parse the JSON and add fragment to current selection or central topic
		set parsedData to my parseTopicJSON(jsonData)
		if errorStatus of parsedData is true then
			return "{ \"error\": \"JSON parsing failed: " & my escapeJSON(errorMsg of parsedData) & "\" }"
		end if
		
		tell application "MindManager"
			tell document 1
				set selItems to selection
				set targetTopic to missing value
				
				if (count of selItems) > 0 then
					set targetTopic to item 1 of selItems
				else
					set targetTopic to central topic
				end if
				
				-- Create the fragment as a subtopic
				set newSubtopic to make new subtopic at end of subtopics of targetTopic
				set name of newSubtopic to topicText of parsedData
				if topicNotes of parsedData is not "" then
					set notes of newSubtopic to topicNotes of parsedData
				end if
				
				-- Build subtopics recursively
				set result to my buildTreeFromJSON(newSubtopic, topicSubtopics of parsedData)
				if result contains "error" then
					return result
				end if
			end tell
		end tell
		
		return "{ \"success\": \"Fragment written successfully\" }"
		
	on error errMsg number errNum
		return "{ \"error\": \"Error in doWriteFragment: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end doWriteFragment

on doSetProperties(jsonData)
	try
		-- Parse the JSON and update properties of existing topic
		set parsedData to my parseTopicJSON(jsonData)
		if errorStatus of parsedData is true then
			return "{ \"error\": \"JSON parsing failed: " & my escapeJSON(errorMsg of parsedData) & "\" }"
		end if
		
		set targetGuid to topicGuid of parsedData
		if targetGuid is "" then
			return "{ \"error\": \"GUID is required for setProperties operation\" }"
		end if
		
		set targetTopic to my _findTopicByID(targetGuid)
		if targetTopic is missing value then
			return "{ \"error\": \"Topic with GUID '" & my escapeJSON(targetGuid) & "' not found\" }"
		end if
		
		tell application "MindManager"
			tell targetTopic
				if topicText of parsedData is not "" then
					set name to topicText of parsedData
				end if
				if topicNotes of parsedData is not "" then
					set notes to topicNotes of parsedData
				end if
			end tell
		end tell
		
		return "{ \"success\": \"Properties updated successfully\" }"
		
	on error errMsg number errNum
		return "{ \"error\": \"Error in doSetProperties: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end doSetProperties

on buildTreeFromJSON(parentTopic, subtopicsData)
	try
		repeat with subtopicData in subtopicsData
			set parsedSubtopic to contents of subtopicData
			
			if class of parsedSubtopic is not record then
				set parsedSubtopic to my parseTopicJSON(parsedSubtopic)
			end if
			
			if class of parsedSubtopic is not record then
				return "{ \"error\": \"Error parsing subtopic: Unsupported data type\" }"
			end if
			
			if errorStatus of parsedSubtopic is true then
				return "{ \"error\": \"Error parsing subtopic: " & my escapeJSON(errorMsg of parsedSubtopic) & "\" }"
			end if
			
			tell application "MindManager"
				tell parentTopic
					set newSubtopic to make new subtopic at end of subtopics
					set name of newSubtopic to topicText of parsedSubtopic
					if topicNotes of parsedSubtopic is not "" then
						set notes of newSubtopic to topicNotes of parsedSubtopic
					end if
				end tell
			end tell
			
			-- Recursively build subtopics
			if (count of topicSubtopics of parsedSubtopic) > 0 then
				set result to my buildTreeFromJSON(newSubtopic, topicSubtopics of parsedSubtopic)
				if result contains "error" then
					return result
				end if
			end if
		end repeat
		
		return "success"
		
	on error errMsg number errNum
		return "{ \"error\": \"Error building tree: " & my escapeJSON(errMsg) & " (Code: " & errNum & ")\" }"
	end try
end buildTreeFromJSON

on parseTopicJSON(jsonInput)
	-- Parse JSON topic data into a normalized record using Foundation
	try
		if class of jsonInput is not text and class of jsonInput is not string then
			set jsonString to jsonInput as text
		else
			set jsonString to jsonInput as text
		end if
		
		set nsString to (NSString's stringWithString:jsonString)
		set jsonData to (nsString's dataUsingEncoding:NSUTF8StringEncoding)
		if jsonData is missing value then error "Unable to encode JSON text as UTF-8."
		
			set parsedObject to (NSJSONSerialization's JSONObjectWithData:jsonData options:0 |error|:(missing value))
			if parsedObject is missing value then
				set errorText to "Unable to parse JSON payload."
				return {errorStatus:true, errorMsg:errorText, topicGuid:"", topicText:"", topicLevel:0, topicNotes:"", topicSubtopics:{}}
			end if
			
			if ((parsedObject's isKindOfClass:NSDictionary) as boolean) is false then
			return {errorStatus:true, errorMsg:"JSON root is not an object.", topicGuid:"", topicText:"", topicLevel:0, topicNotes:"", topicSubtopics:{}}
		end if
		
		return my _dictionaryToTopicRecord(parsedObject)
		
	on error errMsg number errNum
		return {errorStatus:true, errorMsg:"JSON parsing error: " & errMsg & " (Code: " & errNum & ")", topicGuid:"", topicText:"", topicLevel:0, topicNotes:"", topicSubtopics:{}}
	end try
end parseTopicJSON

on _dictionaryToTopicRecord(topicDict)
	set topicGuid to my _coerceToText((topicDict's objectForKey_("guid")))
	set topicText to my _coerceToText((topicDict's objectForKey_("text")))
	set topicNotes to my _coerceToText((topicDict's objectForKey_("notes")))
	
	set rawLevel to (topicDict's objectForKey_("level"))
	set topicLevel to 0
	if rawLevel is not missing value then
		try
			if ((rawLevel's isKindOfClass:NSNull) as boolean) is false then
				try
					set topicLevel to rawLevel as integer
				end try
			end if
		end try
	end if
	
	set subtopicRecords to {}
	set rawSubtopics to (topicDict's objectForKey_("subtopics"))
	if rawSubtopics is not missing value then
		try
			if ((rawSubtopics's isKindOfClass:NSArray) as boolean) is true then
				set subtopicCount to ((rawSubtopics's |count|()) as integer)
				if subtopicCount > 0 then
					repeat with i from 0 to (subtopicCount - 1)
						set subtopicDict to (rawSubtopics's objectAtIndex:i)
						if ((subtopicDict's isKindOfClass:NSDictionary) as boolean) is true then
							set end of subtopicRecords to my _dictionaryToTopicRecord(subtopicDict)
						end if
					end repeat
				end if
			end if
		end try
	end if
	
	return {errorStatus:false, errorMsg:"", topicGuid:topicGuid, topicText:topicText, topicLevel:topicLevel, topicNotes:topicNotes, topicSubtopics:subtopicRecords}
end _dictionaryToTopicRecord

on _coerceToText(valueToCoerce)
	if valueToCoerce is missing value then return ""
	try
		if (valueToCoerce's isKindOfClass:NSNull) as boolean then return ""
	on error
		-- Value is not an Objective-C object; continue
	end try
	try
		return valueToCoerce as text
	on error
		try
			if (valueToCoerce's respondsToSelector:"stringValue") as boolean then
				return valueToCoerce's stringValue() as text
			else if (valueToCoerce's respondsToSelector:"description") as boolean then
				return valueToCoerce's description() as text
			else
				return ""
			end if
		on error
			return ""
		end try
	end try
end _coerceToText

on _findTopicByID(targetID as string)
	if targetID is "" then return missing value
	try
		tell application "MindManager"
			tell document 1
				if id of central topic is targetID then return central topic
				try
					set foundTopics to (every topic whose id is targetID)
					if (count of foundTopics) > 0 then
						return item 1 of foundTopics
					else
						return missing value
					end if
				on error findErr number findErrNum
					if findErrNum is -1728 then
						return missing value
					else
						log "Error using 'whose' clause in _findTopicByID for ID " & targetID & ": " & findErr & " (" & findErrNum & ")"
						error "MindManager search failed unexpectedly." number findErrNum
					end if
				end try
			end tell
		end tell
	on error errMsg number errNum
		log "Error in _findTopicByID searching for " & targetID & ": " & (errMsg as text) & " (Code: " & errNum & ")"
		return missing value
	end try
end _findTopicByID

on escapeJSON(txt)
	local originalDelimiters, textItems, theClass
	try
		set theClass to class of txt
		if theClass is not text and theClass is not string then
			set txt to txt as text
		end if
	on error
		if txt is missing value then return ""
		log "Warning: escapeJSON received non-text data: " & (txt as text)
		return "[Error: Non-text data]"
	end try
	set originalDelimiters to AppleScript's text item delimiters
	try
		set AppleScript's text item delimiters to "\\"
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\\\"
		set txt to textItems as text
		set AppleScript's text item delimiters to "\""
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\\""
		set txt to textItems as text
		set AppleScript's text item delimiters to "/"
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\/"
		set txt to textItems as text
		set AppleScript's text item delimiters to return & linefeed
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to return
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to linefeed
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\n"
		set txt to textItems as text
		set AppleScript's text item delimiters to tab
		set textItems to text items of txt
		set AppleScript's text item delimiters to "\\t"
		set txt to textItems as text
		set AppleScript's text item delimiters to originalDelimiters
		return txt
	on error e
		set AppleScript's text item delimiters to originalDelimiters
		return "[\"Error during JSON escaping: " & (e as text) & "\"]"
	end try
end escapeJSON



================================================
File: mindm/as/write.scpt
================================================
[Non-text file]


================================================
File: mindmap/__init__.py
================================================
# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"



================================================
File: mindmap/export.py
================================================



================================================
File: mindmap/helpers.py
================================================
import re

def escape_mermaid_text(text: str) -> str:
    """Escape special characters in text for Mermaid compatibility.
    
    Args:
        text (str): Text to escape
        
    Returns:
        str: Escaped text for use in Mermaid diagrams
    """
    if not isinstance(text, str):
        return text
    escaped = text.replace("\\", "\\\\") \
                  .replace("\n", "\\n") \
                  .replace("\r", "") \
                  .replace("\"", "\\\"")
    result = []
    for ch in escaped:
        if ord(ch) > 127:
            result.append("\\u{:04x}".format(ord(ch)))
        else:
            result.append(ch)
    return "".join(result)

def replace_unicode_for_markdown(text: str) -> str:
    """Replace Unicode characters for compatibility with Markdown.
    
    Args:
        text (str): Text containing Unicode characters
        
    Returns:
        str: Text with Unicode characters replaced for Markdown compatibility
    """
    return text

def replace_unicode_in_obj(obj):
    """Recursively replace Unicode characters in an object.
    
    Args:
        obj: Object potentially containing Unicode strings
        
    Returns:
        object: Object with Unicode characters replaced
    """
    if isinstance(obj, str):
        return replace_unicode_for_markdown(obj)
    elif isinstance(obj, list):
        return [replace_unicode_in_obj(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: replace_unicode_in_obj(value) for key, value in obj.items()}
    else:
        return obj



================================================
File: mindmap/import.py
================================================



================================================
File: mindmap/mindmap.py
================================================
import uuid

import mindm.mindmanager as mm

DUPLICATED_TAG = 'Duplicated'
DUPLICATE_LABEL = 'DUPLICATE'

class MindmapLink:
    def __init__(self, text: str = '', url: str = '', guid: str = ''):
        """
        Initialize a MindmapLink instance.

        Args:
            text (str): The display text for the link.
            url (str): The URL that the link points to.
            guid (str): A unique identifier for the link.
        """
        self.text = text
        self.url = url
        self.guid = guid

class MindmapImage:
    def __init__(self, text: str = ''):
        """
        Initialize a MindmapImage instance.

        Args:
            text (str): Path to the image.
        """
        self.text = text

class MindmapNotes:
    def __init__(self, text: str = '', xhtml: str = '', rtf: str = ''):
        """
        Initialize a MindmapNotes instance.

        Args:
            text (str): Plain text version of the notes.
            xhtml (str): XHTML formatted notes.
            rtf (str): RTF formatted notes.
        """
        self.text = text
        self.xhtml = xhtml
        self.rtf = rtf

class MindmapIcon:
    def __init__(self, 
                 text: str = '', 
                 is_stock_icon=True, 
                 index: int = 1, 
                 signature: str = '', 
                 path: str = '',
                 group: str = ''):
        """
        Initialize a MindmapIcon instance.

        Args:
            text (str): The display text for the icon.
            is_stock_icon (bool): Flag indicating if the icon is a stock icon.
            index (int): The index of a stock icon.
            signature (str): A unique signature for the icon.
            path (str): File path to the icon if it is custom.
            group (str): The group/category of the icon.
        """
        self.text = text
        self.is_stock_icon = is_stock_icon
        self.index = index
        self.signature = signature
        self.path = path
        self.group = group

class MindmapTag:
    def __init__(self, text: str = ''):
        """
        Initialize a MindmapTag instance.

        Args:
            text (str): The text representing the tag.
        """
        self.text = text

class MindmapReference:
    def __init__(self, 
                 guid_1: str = '', 
                 guid_2: str = '', 
                 direction: int = 1, 
                 label: str = ''):
        """
        Initialize a MindmapReference (relationship) instance.

        Args:
            guid_1 (str): The GUID of the first topic.
            guid_2 (str): The GUID of the second topic.
            direction (int): The direction of the reference (1 indicates a standard direction).
            label (str): A label for the relationship.
        """
        self.guid_1 = guid_1
        self.guid_2 = guid_2
        self.direction = direction
        self.label = label

class MindmapTopic:
    def __init__(self,
                 guid: str = '',
                 text: str = '',
                 rtf: str = '',
                 level: int = 0,
                 selected: bool = False,
                 parent: 'MindmapTopic' = None,
                 subtopics: list['MindmapTopic'] = None,
                 links: list['MindmapLink'] = None,
                 image: 'MindmapImage' = None,
                 icons: list['MindmapIcon'] = None,
                 notes: 'MindmapNotes' = None,
                 tags: list['MindmapTag'] = None,
                 references: list['MindmapReference'] = None):
        """
        Initialize a MindmapTopic instance.

        Args:
            guid (str): Unique identifier for the topic.
            text (str): The text content of the topic.
            rtf (str): RTF formatted text for the topic.
            level (int): The hierarchical level of the topic.
            selected (bool): Flag to indicate if the topic is selected.
            parent (MindmapTopic): The parent topic if any.
            subtopics (list[MindmapTopic]): List of subtopics.
            links (list[MindmapLink]): List of associated links.
            image (MindmapImage): Associated image object.
            icons (list[MindmapIcon]): List of associated icons.
            notes (MindmapNotes): Associated notes.
            tags (list[MindmapTag]): List of associated tags.
            references (list[MindmapReference]): List of associated relationships.
        """
        self.guid = guid
        self.text = text.replace('"', '`').replace("'", "`").replace("\r", "").replace("\n", "")
        self.rtf = rtf
        self.level = level
        self.selected = selected
        self.parent = parent
        self.links = links if links is not None else []
        self.image = image
        self.icons = icons if icons is not None else []
        self.notes = notes
        self.tags = tags if tags is not None else []
        self.references = references if references is not None else []
        self.subtopics = subtopics if subtopics is not None else []


class MindmapDocument:
    def __init__(self, charttype: str = 'auto', turbo_mode: bool = False, inline_editing_mode: bool = False, mermaid_mode: bool = True, macos_access: str = 'appscript'):
        """
        Initialize a MindmapDocument instance which automates MindManager operations.

        Args:
            charttype (str): The type of chart to be used (orgchart, radial, auto).
            turbo_mode (bool): Flag for enabling turbo mode -> use only text.
            inline_editing_mode (bool): Flag for enabling inline editing mode.
            mermaid_mode (bool): Flag for enabling mermaid mode.
            macos_access (str): Method for accessing macOS features (default is 'appscript', alternative is 'applescript').
        """
        self.charttype: str = charttype
        self.turbo_mode: bool = turbo_mode
        self.inline_editing_mode: bool = inline_editing_mode
        self.mermaid_mode: bool = mermaid_mode
        self.macos_access: str = macos_access
        self.mindmap: 'MindmapTopic' = None
        self.central_topic_selected: bool = False
        self.selected_topic_texts: list[str] = []
        self.selected_topic_levels: list[int] = []
        self.selected_topic_ids: list[str] = []
        self.max_topic_level: int = 0
        self.macos_access = macos_access
        self.mindm = mm.Mindmanager(charttype, macos_access)

    def get_mindmap(self, topic=None, mode='full'):
        """
        Retrieve the mind map structure from the currently open MindManager document.

        Args:
            topic: (Optional) A specific topic from which to start building the mindmap.
                   If not provided, the central topic is used.
            mode (str): The mode to use to gather attributes (full=all attributes, content=text+rtf+notes, text=text only).

        Returns:
            bool: True if the mind map was successfully retrieved, otherwise False.
        """
        if self.macos_access == 'applescript':
            # get whole mindmap
            mindmap = self.mindm.get_central_topic()
        else:
            if topic is None:
                topic = self.mindm.get_central_topic()
            
            mindmap = self.get_mindmap_topic_from_topic(self.mindm.get_topic_by_id(topic.guid), mode=mode)

        self.max_topic_level = self.get_max_topic_level(mindmap)
        self.mindmap = mindmap
        return True
    
    def get_max_topic_level(self, mindmap_topic, max_topic_level=0, visited=None):
        """
        Recursively compute the maximum topic level within the mind map.

        Args:
            mindmap_topic (MindmapTopic): The current topic to evaluate.
            max_topic_level (int): The current maximum level found.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.

        Returns:
            int: The highest topic level found in the mindmap.
        """
        if visited is None:
            visited = set()
        if mindmap_topic.guid in visited:
            return max_topic_level
        visited.add(mindmap_topic.guid)
        for subtopic in mindmap_topic.subtopics:
            if subtopic.level > max_topic_level:
                max_topic_level = subtopic.level
            max_topic_level = self.get_max_topic_level(subtopic, max_topic_level, visited)
        return max_topic_level

    def get_parent_topic(self, topic):
        """
        Retrieve the parent topic for a given MindManager topic.

        Args:
            topic: The current topic from which to get the parent.

        Returns:
            MindmapTopic or None: The parent topic wrapped as a MindmapTopic, or None if at the root.
        """
        topic_level = self.mindm.get_level_from_topic(topic)
        if topic_level == 0:
            return None
        parent_topic = self.mindm.get_parent_from_topic(topic)
        parent_mindmap_topic = MindmapTopic(
            guid=self.mindm.get_guid_from_topic(parent_topic),
            text=self.mindm.get_text_from_topic(parent_topic), 
            level=self.mindm.get_level_from_topic(parent_topic),
            parent=self.get_parent_topic(parent_topic),
        )
        return parent_mindmap_topic

    def get_selection(self):
        """
        Retrieve the currently selected topics in the MindManager document.

        Returns:
            list[MindmapTopic]: A list of MindmapTopic instances representing the selection.
        """
        selection = self.mindm.get_selection()
        mindmap_topics = []
        for topic in selection:
            level = self.mindm.get_level_from_topic(topic)
            mindmap_topic = MindmapTopic(
                guid=self.mindm.get_guid_from_topic(topic),
                text=self.mindm.get_text_from_topic(topic), 
                level=level,
                parent=self.get_parent_topic(topic),
                selected=True,
            )
            mindmap_topics.append(mindmap_topic)
        self.get_topic_texts_from_selection(mindmap_topics)
        return mindmap_topics

    def get_mindmap_topic_from_topic(self, topic, parent_topic=None, mode='full'):
        """
        Recursively convert a MindManager topic into a MindmapTopic object.

        Args:
            topic: The current MindManager topic to convert.
            parent_topic (MindmapTopic): The parent MindmapTopic, if any.
            mode (str): The mode to use to gather attributes (full=all attributes, content=text+rtf+notes, text=text only).

        Returns:
            MindmapTopic: The converted topic with its subtopics.
        """
        if mode == 'full':
            mindmap_topic = self.mindm.get_mindmaptopic_from_topic_full(topic)
            mindmap_topic.parent = parent_topic
        elif mode == 'content':
            mindmap_topic = self.mindm.get_mindmaptopic_from_topic_content(topic)
        else:
            mindmap_topic = self.mindm.get_mindmaptopic_from_topic(topic)

        subtopics = self.mindm.get_subtopics_from_topic(topic)
        mindmap_subtopics = []
        for subtopic in subtopics:
            child = self.get_mindmap_topic_from_topic(subtopic, parent_topic=mindmap_topic, mode=mode)
            mindmap_subtopics.append(child)
        mindmap_topic.subtopics = mindmap_subtopics
        return mindmap_topic 

    def get_relationships_from_mindmap(self, mindmap, references, visited=None):
        """
        Recursively extract relationships (references) from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            references (list[MindmapReference]): List to collect the relationships.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for reference in mindmap.references:
            if reference.direction == 1:
                references.append(MindmapReference(
                    guid_1=reference.guid_1,
                    guid_2=reference.guid_2,
                    direction=reference.direction,
                    label=reference.label
                ))
        for subtopic in mindmap.subtopics:
            self.get_relationships_from_mindmap(subtopic, references, visited)

    def get_topic_links_from_mindmap(self, mindmap, links, visited=None):
        """
        Recursively extract topic links from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            links (list[MindmapReference]): List to collect topic links as MindmapReference objects.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for link in mindmap.links:
            if link.guid != '':
                links.append(MindmapReference(
                    guid_1=mindmap.guid, 
                    guid_2=link.guid, 
                    direction=1, 
                    label=link.text
                ))
        for subtopic in mindmap.subtopics:
            self.get_topic_links_from_mindmap(subtopic, links, visited)

    def get_tags_from_mindmap(self, mindmap, tags, visited=None):
        """
        Recursively collect unique tags from the mindmap.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            tags (list[str]): List to collect tag texts.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for tag in mindmap.tags:
            if tag.text != '' and tag.text not in tags:
                tags.append(tag.text)
        for subtopic in mindmap.subtopics:
            self.get_tags_from_mindmap(subtopic, tags, visited)

    def get_parents_from_mindmap(self, mindmap, parents, visited=None):
        """
        Build a dictionary mapping subtopic GUIDs to their parent's GUID.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            parents (dict): Dictionary to store parent-child GUID mappings.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        for subtopic in mindmap.subtopics:
            if subtopic.guid not in parents:
                parents[subtopic.guid] = mindmap.guid
                self.get_parents_from_mindmap(subtopic, parents, visited)
        return

    def get_map_icons_and_fix_refs_from_mindmap(self, mindmap, map_icons: list['MindmapIcon'], visited=None):
        """
        Extract icons from mindmap topics and fix their references if needed.

        Args:
            mindmap (MindmapTopic): The current topic in the mindmap.
            map_icons (list[MindmapIcon]): List to collect unique icons.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if mindmap.guid in visited:
            return
        visited.add(mindmap.guid)
        
        for i, topic_icon_ref in enumerate(mindmap.icons):
            # Only process non-stock icons belonging to the 'Types' group
            if not topic_icon_ref.is_stock_icon and topic_icon_ref.group == 'Types':
                found = False
                for map_icon in map_icons:
                    if map_icon.signature == topic_icon_ref.signature:
                        found = True
                        new_icon = map_icon
                        break
                if not found:
                    new_icon = MindmapIcon(
                        text=topic_icon_ref.text, 
                        index=topic_icon_ref.index,
                        is_stock_icon=topic_icon_ref.is_stock_icon, 
                        path=topic_icon_ref.path,
                        signature=topic_icon_ref.signature,
                        group=topic_icon_ref.group)                
                    map_icons.append(new_icon)
                mindmap.icons[i] = new_icon
        for subtopic in mindmap.subtopics:
            self.get_map_icons_and_fix_refs_from_mindmap(subtopic, map_icons, visited)

    def count_parent_and_child_occurrences(self, mindmap_topic, guid_counts, visited=None):
        """
        Recursively count the occurrences of parent and child relationships for each topic.

        Args:
            mindmap_topic (MindmapTopic): The current topic in the mindmap.
            guid_counts (dict): Dictionary to store counts with topic GUID as keys.
            visited (set): Set of visited topic GUIDs to avoid infinite recursion.
        """
        if visited is None:
            visited = set()
        if str(mindmap_topic.guid) == '':
            mindmap_topic.guid = str(uuid.uuid4())
        if mindmap_topic.guid not in visited:
            visited.add(mindmap_topic.guid)
            if mindmap_topic.guid not in guid_counts:
                guid_counts[mindmap_topic.guid] = {'parent': 0, 'child': 0}
            for subtopic in mindmap_topic.subtopics:
                if mindmap_topic.guid:
                    guid_counts[mindmap_topic.guid]['parent'] += 1
                if subtopic.guid:
                    if subtopic.guid not in guid_counts:
                        guid_counts[subtopic.guid] = {'parent': 0, 'child': 0}
                    guid_counts[subtopic.guid]['child'] += 1
                self.count_parent_and_child_occurrences(subtopic, guid_counts, visited)

    def get_topic_texts_from_selection(self, mindmap_topics):
        """
        Extract topic texts, levels, and GUIDs from selected topics.

        Args:
            mindmap_topics (list[MindmapTopic]): List of topics to process.
        """
        topic_texts = []
        topic_levels = []
        topic_ids = []
        central_topic_selected = False
        for topic in mindmap_topics:
            if topic.selected:
                if topic.level > 0:
                    topic_texts.append(topic.text)
                    topic_levels.append(topic.level)
                    topic_ids.append(topic.guid)
                else:
                    central_topic_selected = True

        self.central_topic_selected = central_topic_selected
        self.selected_topic_texts = topic_texts
        self.selected_topic_levels = topic_levels
        self.selected_topic_ids = topic_ids
            
    def clone_mindmap_topic(self, mindmap_topic, subtopics: list['MindmapTopic'] = None, parent=None):
        """
        Clone a MindmapTopic instance including its subtopics.

        Args:
            mindmap_topic (MindmapTopic): The topic to clone.
            subtopics (list[MindmapTopic], optional): A list of subtopics to clone.
            parent: The parent for the cloned topic.

        Returns:
            MindmapTopic: A new instance that is a clone of the given topic.
        """
        cloned_subtopics = []
        if subtopics is not None:
            for subtopic in subtopics:
                cloned_subtopic = self.clone_mindmap_topic(subtopic)
                cloned_subtopics.append(cloned_subtopic)
        return MindmapTopic(
            guid=mindmap_topic.guid,
            text=mindmap_topic.text, 
            rtf=mindmap_topic.rtf,
            level=mindmap_topic.level,
            parent=parent,
            links=mindmap_topic.links,
            image=mindmap_topic.image,
            icons=mindmap_topic.icons,
            notes=mindmap_topic.notes,
            tags=mindmap_topic.tags,
            subtopics=cloned_subtopics
        )

    def update_done(self, topic_guid, mindmap_topic, level, done, done_global):
        """
        Update tracking dictionaries for processed topics and create duplicate links/tags.

        Args:
            topic_guid (str): The GUID of the current topic in MindManager.
            mindmap_topic (MindmapTopic): The MindmapTopic being processed.
            level (int): The current level in the topic hierarchy.
            done (dict): Dictionary tracking topics processed at a given level.
            done_global (dict): Global dictionary tracking processed topics for duplicate detection.
        """
        if mindmap_topic.guid == '':
            return
        if level <= 1:
            done = {}
        elif level >= 2: 
            done[mindmap_topic.guid] = [topic_guid] if mindmap_topic.guid not in done else done[mindmap_topic.guid] + [topic_guid]
        if mindmap_topic.guid in done_global:
            # Check for duplicate relationships and add links/tags accordingly.
            if self.guid_counts[mindmap_topic.guid]['child'] < 11 and self.guid_counts[mindmap_topic.guid]['parent'] >= 0:
                for i in range(len(done_global[mindmap_topic.guid])):
                    link_from = topic_guid
                    link_to = done_global[mindmap_topic.guid][i]
                    self.mindm.add_topic_link(link_from, link_to, DUPLICATE_LABEL)
                    self.mindm.add_topic_link(link_to, link_from, DUPLICATE_LABEL)
                if len(done_global[mindmap_topic.guid]) == 1:
                    self.mindm.add_tag_to_topic(topic=None, tag_text=DUPLICATED_TAG, topic_guid=done_global[mindmap_topic.guid][0])
            self.mindm.add_tag_to_topic(topic=None, tag_text=DUPLICATED_TAG, topic_guid=topic_guid)
            done_global[mindmap_topic.guid] = done_global[mindmap_topic.guid] + [topic_guid]
        else:
            done_global[mindmap_topic.guid] = [topic_guid]

    def set_topic_from_mindmap_topic(self, topic, mindmap_topic, map_icons, done=None, done_global=None, level=0):
        """
        Create or update a MindManager topic from a MindmapTopic instance recursively.

        Args:
            topic: The current MindManager topic to update.
            mindmap_topic (MindmapTopic): The source MindmapTopic data.
            map_icons (list[MindmapIcon]): List of map icons to use.
            done (dict, optional): Dictionary tracking processed topics at current level.
            done_global (dict, optional): Global dictionary for tracking duplicate processing.
            level (int): Current hierarchical level.
            
        Returns:
            MindmapTopic: The processed MindmapTopic.
        """
        if done is None:
            done = {}
        if done_global is None:
            done_global = {}
        try:
            if self.turbo_mode:
                topic_guid = self.mindm.get_guid_from_topic(topic)
                self.update_done(topic_guid, mindmap_topic, level, done, done_global)
                for subtopic in mindmap_topic.subtopics:
                    try:
                        sub = self.mindm.add_subtopic_to_topic(topic, subtopic.text)
                        self.set_topic_from_mindmap_topic(sub, subtopic, map_icons, done, done_global, level + 1)
                    except Exception as e:
                        print(f"Error(1) processing topic/subtopic {mindmap_topic.guid}/{subtopic.guid}: {e}")
            else:
                topic, topic_guid = self.mindm.set_topic_from_mindmap_topic(topic, mindmap_topic, map_icons)
                self.update_done(topic_guid, mindmap_topic, level, done, done_global)

                if mindmap_topic.subtopics and len(mindmap_topic.subtopics) > 0:
                    # Sort subtopics alphabetically by text
                    mindmap_topic.subtopics.sort(key=lambda sub: sub.text)

                for subtopic in mindmap_topic.subtopics:
                    try:
                        if subtopic.guid in done:
                            this_guid_as_parent_exists = self.check_parent_exists(topic_guid, subtopic.guid)
                            if not this_guid_as_parent_exists:
                                cloned_subtopic = self.clone_mindmap_topic(subtopic)
                                sub = self.mindm.add_subtopic_to_topic(topic, cloned_subtopic.text)
                                self.set_topic_from_mindmap_topic(sub, cloned_subtopic, map_icons, done, done_global, level + 1)
                        else:
                            sub = self.mindm.add_subtopic_to_topic(topic, subtopic.text)
                            self.set_topic_from_mindmap_topic(sub, subtopic, map_icons, done, done_global, level + 1)
                    except Exception as e:
                        print(f"Error(2) processing topic/subtopic {mindmap_topic.guid}/{subtopic.guid}: {e}")
            return mindmap_topic
        except Exception as e:
            print(f"Error in set_topic_from_mindmap_topic at level {level} with topic {mindmap_topic.guid}: {e}")

    def check_parent_exists(self, topic_guid, this_guid, visited=None):
        """
        Recursively check if a parent-child relationship exists between topics.

        Args:
            topic_guid (str): The GUID of the topic to check.
            this_guid (str): The GUID that might be a parent of the topic.
            visited (set, optional): Set of visited GUIDs to avoid infinite recursion.

        Returns:
            bool: True if the parent-child relationship exists, False otherwise.
        """
        if visited is None:
            visited = set()
        if topic_guid in visited:
            return False
        visited.add(topic_guid)
        
        check = False
        if topic_guid in self.parents:
            parent_guid = self.parents[topic_guid]
            if parent_guid == this_guid:
                check = True
            else:
                check = self.check_parent_exists(parent_guid, this_guid, visited)
        return check

    def create_mindmap(self, verbose=False):
        """
        Create a MindManager mindmap document from the internal MindmapTopic structure.
        This includes counting occurrences, extracting tags/icons, and setting up relationships and links.

        Args:
            verbose (bool): (Optional) Enable verbose output.
        """
        tags = []
        map_icons = []
        relationships = []
        links = []

        self.parents = {}
        self.guid_counts = {}
        self.count_parent_and_child_occurrences(self.mindmap, self.guid_counts)
        self.get_parents_from_mindmap(self.mindmap, self.parents)

        self.get_tags_from_mindmap(self.mindmap, tags)
        self.get_map_icons_and_fix_refs_from_mindmap(self.mindmap, map_icons)
        self.get_relationships_from_mindmap(self.mindmap, relationships)
        self.get_topic_links_from_mindmap(self.mindmap, links)

        self.mindm.add_document(0)
        self.mindm.create_map_icons(map_icons)
        self.mindm.create_tags(tags, DUPLICATED_TAG)

        if self.mindm.platform == 'darwin' and self.macos_access == 'applescript':
            self.mindm.set_topic_from_mindmap_topic(None, self.mindmap, map_icons)
            self.get_mindmap()
        else:
            central_topic = self.mindm.get_central_topic()
            self.mindm.set_text_to_topic(self.mindm.get_topic_by_id(central_topic.guid), self.mindmap.text)

            done_global = {}
            self.set_topic_from_mindmap_topic(
                topic=self.mindm.get_topic_by_id(central_topic.guid),
                mindmap_topic=self.mindmap,
                map_icons=map_icons,
                done={},
                done_global=done_global)

        # Create relationships between topics
        for reference in relationships:
            object1_guids = done_global[reference.guid_1]
            object2_guids = done_global[reference.guid_2]
            for object1_guid in object1_guids:
                for object2_guid in object2_guids:
                    self.mindm.add_relationship(object1_guid, object2_guid, reference.label)

        # Create topic links
        for link in links:
            object1_guids = done_global[link.guid_1]
            object2_guids = done_global[link.guid_2]
            for object1_guid in object1_guids:
                for object2_guid in object2_guids:
                    self.mindm.add_topic_link(object1_guid, object2_guid, link.label)

    def create_mindmap_and_finalize(self):
        """
        Create the mindmap document and finalize it.
        """
        self.create_mindmap()
        self.finalize()

    def finalize(self):
        """
        Finalize the mindmap document by ensuring the maximum topic level is set, then calling MindManager's finalize.
        """
        if self.max_topic_level == 0:
            self.max_topic_level = self.get_max_topic_level(self.mindmap)
        self.mindm.finalize(self.max_topic_level)
    
    def set_background_image(self, image_path):
        """
        Set the background image for the MindManager document.

        Args:
            image_path (str): The file path to the background image.
        """
        self.mindm.set_document_background_image(image_path)
    
    def get_library_folder(self):
        """
        Get the library folder used by MindManager.

        Returns:
            The path to the library folder.
        """
        return self.mindm.get_library_folder()
    
    def get_grounding_information(self):
        """
        Extract grounding information from the mindmap, including the central topic and selected subtopics.

        Returns:
            tuple: (top_most_topic, subtopics) where top_most_topic is the central topic or a concatenated string
                   of non-selected topics, and subtopics is a comma-separated string of selected subtopics.
        """
        central_topic_text = self.mindmap.text
        self.get_selection()
        subtopics = ""
        if len(self.selected_topic_texts) == 0: 
            top_most_topic = central_topic_text
        else:
            if self.central_topic_selected:
                top_most_topic = central_topic_text
                subtopics =  ",".join(self.selected_topic_texts)
            else:
                min_level = min(self.selected_topic_levels)
                max_level = max(self.selected_topic_levels)
                if (min_level == max_level):
                    top_most_topic = central_topic_text
                    subtopics =  ",".join(self.selected_topic_texts)
                else:
                    top_most_topic = ""
                    for i in range(len(self.selected_topic_levels)):
                        if self.selected_topic_levels[i] != max_level:
                            top_most_topic += self.selected_topic_texts[i] + "/"
                        else:
                            subtopics += self.selected_topic_texts[i] + ","

                    if top_most_topic.endswith("/"):
                        top_most_topic = top_most_topic[:-1]
                    if subtopics.endswith(","):
                        subtopics = subtopics[:-1]        
        return top_most_topic, subtopics



================================================
File: mindmap/serialization.py
================================================
from mindmap.mindmap import *
from mindmap import helpers

import json
import re
import uuid
import html2text

IGNORE_RTF = True

def serialize_object(obj, guid_mapping, name='', visited=None, ignore_rtf=True):
    """Serialize an object recursively, handling special fields and mapping GUIDs to IDs.
    
    Args:
        obj: The object to serialize
        guid_mapping: Dictionary mapping GUIDs to numeric IDs
        name (str, optional): The name of the attribute being serialized. Defaults to ''.
        visited (set, optional): Set of object IDs that have been visited to prevent cycles. Defaults to None.
        ignore_rtf (bool, optional): Whether to ignore RTF content. Defaults to True.
        
    Returns:
        object: Serialized representation of the input object to be exported at JSON
    """
    if visited is None:
        visited = set()
    if name == 'topic':
        if id(obj) in visited:
            return None
        visited.add(id(obj))
    visited.add(id(obj))
    if isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    if isinstance(obj, list):
        attr_name = 'topic' if name == 'subtopics' else ''
        return [serialize_object(item, guid_mapping, attr_name, visited) for item in obj]
    if isinstance(obj, dict):
        return {str(k): serialize_object(v, guid_mapping, visited=visited) for k, v in obj.items()}
    if hasattr(obj, '__dict__'):
        serialized = {}
        for attr_name, attr_value in vars(obj).items():
            if attr_name in ["parent", "level", "selected"]: 
                continue
            if attr_name in ["rtf"]:
                if ignore_rtf == True:
                    continue
            if attr_value is None or attr_value == "" or attr_value == []:
                continue
            new_attr_name = attr_name
            if new_attr_name in ["guid", "guid_1", "guid_2"]:
                if new_attr_name == "guid":
                    new_attr_name = "id"
                elif new_attr_name == "guid_1":
                    new_attr_name = "id_1"
                elif new_attr_name == "guid_2":
                    new_attr_name = "id_2"
                serialized[new_attr_name] = guid_mapping[attr_value]
            else:
                dict_val = serialize_object(attr_value, guid_mapping, attr_name, visited)
                if dict_val != {}:
                    serialized[new_attr_name] = dict_val
        return serialized
    return str(obj)

def serialize_object_simple(obj, name='', visited=None, ignore_rtf=True):
    """Serialize an object recursively without GUID mapping.
    
    Args:
        obj: The object to serialize
        name (str, optional): The name of the attribute being serialized. Defaults to ''.
        visited (set, optional): Set of object IDs that have been visited to prevent cycles. Defaults to None.
        ignore_rtf (bool, optional): Whether to ignore RTF content. Defaults to True.
        
    Returns:
        object: Simplified serialized representation of the input object to be exported at JSON
    """
    if visited is None:
        visited = set()
    if name == 'topic':
        if id(obj) in visited:
            return None
        visited.add(id(obj))
    if isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    if isinstance(obj, list):
        attr_name = 'topic' if name == 'subtopics' else ''
        return [serialize_object_simple(item, attr_name, visited) for item in obj]
    if isinstance(obj, dict):
        return {str(k): serialize_object_simple(v, k, visited) for k, v in obj.items()}
    if hasattr(obj, '__dict__'):
        serialized = {}
        for attr_name, attr_value in vars(obj).items():
            if attr_name in ["parent", "level", "selected"]:
                continue
            if attr_name in ["rtf"]:
                if ignore_rtf == True:
                    continue
            if attr_value is None or attr_value == "" or attr_value == []:
                continue
            dict_val = serialize_object_simple(attr_value, attr_name, visited)
            if dict_val != {}:
                serialized[attr_name] = dict_val
        return serialized
    return str(obj)

def serialize_mindmap(root_topic, guid_mapping, id_only=False):
    """Serialize a mindmap to valid Mermaid format including id and all other attributes (optional).
    
    Args:
        root_topic (MindmapTopic): Root topic of the mindmap
        guid_mapping (dict): Dictionary mapping GUIDs to numeric IDs
        id_only (bool, optional): If True, only include IDs without detailed attributes. Defaults to False.
        
    Returns:
        str: Mermaid formatted string representing the mindmap
    """
    lines = ["mindmap"]

    def serialize_topic_attributes(topic, guid_mapping, ignore_rtf=True):
        """Extract and serialize the attributes of a MindmapTopic.
        
        Args:
            topic (MindmapTopic): The topic to serialize
            guid_mapping (dict): Dictionary mapping GUIDs to numeric IDs
            
        Returns:
            dict: Dictionary containing serialized topic attributes
        """
        d = {}
        d["id"] = guid_mapping.get(topic.guid, topic.guid)
        #d["text"] = topic.text
        if topic.rtf != topic.text and not ignore_rtf == True:
            d["rtf"] = topic.rtf
        if topic.selected == True:
            d["selected"] = topic.selected
        if topic.links:
            d["links"] = []
            for link in topic.links:
                l = {}
                if link.text:
                    l["text"] = link.text
                if link.url:
                    l["url"] = link.url
                if link.guid:
                    l["id"] = guid_mapping.get(link.guid, link.guid)
                d["links"].append(l)
        if topic.image:
            d["image"] = {"text": topic.image.text}
        if topic.icons:
            d["icons"] = []
            for icon in topic.icons:
                i = {}
                if icon.text:
                    i["text"] = icon.text
                if icon.is_stock_icon is not None:
                    i["is_stock_icon"] = icon.is_stock_icon
                if icon.index is not None:
                    i["index"] = icon.index
                if icon.signature:
                    i["signature"] = icon.signature
                if icon.path:
                    i["path"] = icon.path
                if icon.group:
                    i["group"] = icon.group
                d["icons"].append(i)
        if topic.notes and (topic.notes.text or topic.notes.xhtml or topic.notes.rtf):
            notes = {}
            if topic.notes.text:
                notes["text"] = topic.notes.text
            if topic.notes.xhtml:
                notes["xhtml"] = topic.notes.xhtml
            if topic.notes.rtf:
                notes["rtf"] = topic.notes.rtf
            if notes != {}:
                d["notes"] = notes
        if topic.tags:
            d["tags"] = [tag.text for tag in topic.tags]
        if topic.references:
            d["references"] = []
            for ref in topic.references:
                r = {}
                if ref.guid_1:
                    r["id_1"] = guid_mapping.get(ref.guid_1, ref.guid_1)
                if ref.guid_2:
                    r["id_2"] = guid_mapping.get(ref.guid_2, ref.guid_2)
                if ref.direction:
                    r["direction"] = ref.direction
                if ref.label:
                    r["label"] = ref.label
                d["references"].append(r)
        d = helpers.replace_unicode_in_obj(d)
        return d
    
    def traverse(topic, indent):
        indent_str = "  " * indent
        node_text = helpers.escape_mermaid_text(topic.text)
        if id_only:
            id = guid_mapping.get(topic.guid, topic.guid)
            line = f"{indent_str}id{id}[{node_text}]"
            #line = f"{indent_str}({node_text})"
            #topic_attrs = {"id": id}
        else:
            line = f"{indent_str}[{node_text}]"
            topic_attrs = serialize_topic_attributes(topic, guid_mapping, ignore_rtf=IGNORE_RTF)
            json_comment = json.dumps(topic_attrs, ensure_ascii=True)
            line += f" %% {json_comment}"
        lines.append(line)
        for sub in topic.subtopics:
            traverse(sub, indent + 1)

    traverse(root_topic, 1)
    return "\n".join(lines)

def serialize_mindmap_simple(root_topic: MindmapTopic) -> str:
    """Serialize a mindmap to a simplified Mermaid format with indentation-only nodes.
    
    Args:
        root_topic (MindmapTopic): Root topic of the mindmap
        
    Returns:
        str: Mermaid formatted string (text and indentation only)
    """
    lines = ["mindmap"]

    def traverse(topic, indent):
        indent_str = "  " * indent
        text = topic.text if topic.text is not None else ""
        lines.append(f"{indent_str}{text}")
        for sub in topic.subtopics:
            traverse(sub, indent + 1)

    traverse(root_topic, 1)
    return "\n".join(lines)

def serialize_mindmap_markdown(root_topic, include_notes=True):
    """Serialize a mindmap to markdown including notes (optional).
    
    Args:
        root_topic (MindmapTopic): Root topic of the mindmap
        include_notes (bool, optional): If True, notes are included
        
    Returns:
        str: Markdown formatted string representing the mindmap
    """

    lines = []
    
    def traverse(topic, lines, level, prefix, index):
        text = topic.text
        notes_text = ""
        notes_xhtml = ""
        notes_rtf = ""

        if level > 0:
            if prefix == '':
                prefix = str(index)
            else:
                prefix = f"{prefix}.{index}"
        
        if topic.notes:
            if topic.notes.text or topic.notes.xhtml or topic.notes.rtf:
                if topic.notes.text:
                    notes_text = topic.notes.text
                if topic.notes.xhtml:
                    xhtml = topic.notes.xhtml
                    root_match = re.search(r'<(?:root|body)[^>]*>(.*?)</(?:root|body)>', xhtml, re.DOTALL | re.IGNORECASE)
                    if root_match:
                        xhtml = root_match.group(1)
                    xhtml = re.sub(r'<\?xml[^>]*\?>', '', xhtml)
                    xhtml = re.sub(r'<!DOCTYPE[^>]*>', '', xhtml)
                    try:
                        h = html2text.HTML2Text()
                        h.ignore_links = False
                        h.ignore_images = False
                        h.body_width = 0  # Don't wrap lines
                        notes_xhtml = h.handle(xhtml).strip()
                    except ImportError:
                        notes_xhtml = re.sub(r'<[^>]*>', '', xhtml).strip()
                if topic.notes.rtf:
                    # not implemented due to bad results
                    pass

        if include_notes and (notes_text or notes_xhtml or notes_rtf):
            notes_content = notes_text
            if notes_rtf:
                notes_content = notes_rtf
            if notes_xhtml:
                notes_content = notes_xhtml
            notes = f"Notes: {notes_content}  "
        else:
            notes = ""
        
        if topic.subtopics:
            line = f"{(level + 1) * '#'} {prefix if level > 0 else ''} {text}  "
            lines.append(line)
            if notes:
                lines.append(notes)

            sub_index = 0
            for sub in topic.subtopics:
                sub_index += 1
                traverse(sub, lines, level + 1, prefix, sub_index)
        else:
            line = f"- {text}  "
            lines.append(line)
            if notes:
                lines.append(notes)

    traverse(root_topic, lines, 0, '', 0)
    return "\n".join(lines)


def deserialize_mermaid_with_id(mermaid_text: str, guid_mapping: dict) -> MindmapTopic:
    """Convert Mermaid text with id to a Mindmap structure.
    
    Args:
        mermaid_text (str): Mermaid formatted string to parse
        guid_mapping (dict): Dictionary mapping numeric IDs to GUIDs
        
    Returns:
        MindmapTopic: Root topic of the deserialized mindmap
    """
    id_to_guid = {id_num: guid for guid, id_num in guid_mapping.items()}
    lines = [line for line in mermaid_text.splitlines() if line.strip()]
    if lines and lines[0].strip().lower() == "mindmap":
        lines = lines[1:]
    node_pattern = re.compile(r"^(id(\d+))\[(.*)\]$")
    root = None
    stack = []
    for line in lines:
        indent = len(line) - len(line.lstrip(" "))
        level = indent // 2
        stripped = line.lstrip(" ")
        match = node_pattern.match(stripped)
        if not match:
            continue        
        node_id_str = match.group(1)
        id_number = int(match.group(2))
        node_text = match.group(3)        
        if id_number in id_to_guid:
            guid = id_to_guid[id_number]
        else:
            guid = str(uuid.uuid4())
            id_to_guid[id_number] = guid
        node = MindmapTopic(guid=guid, text=node_text, level=level)
        if root is None:
            root = node
            stack.append((level, node))
            continue
        while stack and stack[-1][0] >= level:
            stack.pop()
        if stack:
            parent = stack[-1][1]
            node.parent = parent
            parent.subtopics.append(node)
        else:
            root.subtopics.append(node)
            node.parent = root
        stack.append((level, node))
    return root

def deserialize_mermaid_simple(mermaid_text: str) -> MindmapTopic:
    """Convert a simple indentation-based Mermaid mindmap to a Mindmap structure.
    
    Args:
        mermaid_text (str): Mermaid formatted string containing only textual nodes
            expressed via indentation (no IDs or metadata)
        
    Returns:
        MindmapTopic: Root topic of the deserialized mindmap
    """
    lines = [line for line in mermaid_text.splitlines() if line.strip()]
    if lines and lines[0].strip().lower() == "mindmap":
        lines = lines[1:]
    root = None
    stack = []
    for raw_line in lines:
        # Allow optional inline comments and convert tabs to spaces for consistent indentation
        line = raw_line.expandtabs(2)
        line = line.split("%%", 1)[0]
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith("[") and stripped.endswith("]"):
            stripped = stripped[1:-1]
        indent = len(line) - len(line.lstrip(" "))
        level = indent // 2
        node = MindmapTopic(guid=str(uuid.uuid4()), text=stripped, level=level)
        if root is None:
            root = node
            stack = [(level, node)]
            continue
        while stack and stack[-1][0] >= level:
            stack.pop()
        if stack:
            parent = stack[-1][1]
            node.parent = parent
            parent.subtopics.append(node)
        else:
            # Fallback for malformed inputs that contain multiple root-level nodes
            if root:
                node.parent = root
                root.subtopics.append(node)
        stack.append((level, node))
    return root

def deserialize_mermaid_full(mermaid_text: str, guid_mapping: dict) -> MindmapTopic:
    """Convert Mermaid text with metadata to a Mindmap structure.
    
    Args:
        mermaid_text (str): Mermaid formatted string with JSON metadata to parse
        guid_mapping (dict): Dictionary mapping numeric IDs to GUIDs
        
    Returns:
        MindmapTopic: Root topic of the fully deserialized mindmap with all attributes
    """
    id_to_guid = {v: k for k, v in guid_mapping.items()}
    lines = [line for line in mermaid_text.splitlines() if line.strip()]
    if lines and lines[0].strip().lower() == "mindmap":
        lines = lines[1:]
    pattern = re.compile(r"^( *)(\[.*?\])\s*%%\s*(\{.*\})\s*$")
    root = None
    stack = []
    
    def restore_guid(numeric_id):
        try:
            num = int(numeric_id)
        except:
            return str(uuid.uuid4())
        if num in id_to_guid:
            return id_to_guid[num]
        else:
            new_guid = str(uuid.uuid4())
            id_to_guid[num] = new_guid
            return new_guid

    def process_subobject(field_dict: dict, id_field: str) -> dict:
        if id_field in field_dict:
            field_dict[id_field] = restore_guid(field_dict[id_field])
        return field_dict

    for line in lines:
        m = pattern.match(line)
        if not m:
            continue
        indent_str, bracket_part, json_part = m.groups()
        level = len(indent_str) // 2
        fallback_text = bracket_part.strip()[1:-1]
        try:
            attrs = json.loads(json_part)
        except Exception as e:
            attrs = {}
        if "id" in attrs:
            node_guid = restore_guid(attrs["id"])
        else:
            node_guid = str(uuid.uuid4())
        node_text = attrs.get("text", fallback_text)
        node_rtf = attrs.get("rtf", "")
        selected = attrs.get("selected", False)
        links = []
        if "links" in attrs and isinstance(attrs["links"], list):
            for link_dict in attrs["links"]:
                ld = dict(link_dict)
                ld = process_subobject(ld, "id")
                link_text = ld.get("text", "")
                link_url = ld.get("url", "")
                link_guid = ld.get("id", "")
                links.append(MindmapLink(text=link_text, url=link_url, guid=link_guid))
        image_obj = None
        if "image" in attrs and isinstance(attrs["image"], dict):
            image_obj = MindmapImage(text=attrs["image"].get("text", ""))
        icons = []
        if "icons" in attrs and isinstance(attrs["icons"], list):
            for icon_dict in attrs["icons"]:
                idict = dict(icon_dict)
                icons.append(MindmapIcon(
                    text=idict.get("text", ""),
                    is_stock_icon=idict.get("is_stock_icon", True),
                    index=idict.get("index", 1),
                    signature=idict.get("signature", ""),
                    path=idict.get("path", ""),
                    group=idict.get("group", "")
                ))
        notes_obj = None
        if "notes" in attrs:
            if isinstance(attrs["notes"], dict):
                notes_obj = MindmapNotes(
                    text=attrs["notes"].get("text", ""),
                    xhtml=attrs["notes"].get("xhtml", ""),
                    rtf=attrs["notes"].get("rtf", "")
                )
            elif isinstance(attrs["notes"], str):
                notes_obj = MindmapNotes(text=attrs["notes"])
        tags = []
        if "tags" in attrs and isinstance(attrs["tags"], list):
            for tag_item in attrs["tags"]:
                if isinstance(tag_item, dict):
                    tag_text = tag_item.get("text", "")
                else:
                    tag_text = str(tag_item)
                tags.append(MindmapTag(text=tag_text))
        references = []
        if "references" in attrs and isinstance(attrs["references"], list):
            for ref_dict in attrs["references"]:
                rd = dict(ref_dict)
                rd = process_subobject(rd, "id_1")
                rd = process_subobject(rd, "id_2")
                direction = rd.get("direction", None)
                label = rd.get("label", "")
                references.append(MindmapReference(
                    guid_1=rd.get("id_1", ""),
                    guid_2=rd.get("id_2", ""),
                    direction=direction,
                    label=label
                ))
        node = MindmapTopic(guid=node_guid, text=node_text, rtf=node_rtf, level=level, selected=selected)
        node.links = links
        node.image = image_obj
        node.icons = icons
        node.notes = notes_obj
        node.tags = tags
        node.references = references
        while stack and stack[-1][0] >= level:
            stack.pop()
        if stack:
            parent = stack[-1][1]
            node.parent = parent
            parent.subtopics.append(node)
        else:
            root = node
        stack.append((level, node))
    return root

def build_mapping(topic, guid_mapping):
    """Build a mapping of GUIDs to numeric IDs for an entire mindmap.
    
    Args:
        topic (MindmapTopic): Root topic of the mindmap
        guid_mapping (dict): Dictionary to store GUID to ID mappings
        
    Returns:
        None: The mapping is updated in-place
    """
    if topic.guid not in guid_mapping:
        guid_mapping[topic.guid] = len(guid_mapping) + 1
    for sub in topic.subtopics:
        build_mapping(sub, guid_mapping)


